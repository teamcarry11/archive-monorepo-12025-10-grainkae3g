{
  "slug" : "9600-debugging-finding-fixing-issues",
  "meta" : {
    "slug" : "9600-debugging-finding-fixing-issues",
    "title" : "kae3g 9599: Debugging - Finding and Fixing Issues",
    "filename" : "9600-debugging-finding-fixing-issues.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9599: Debugging - Finding and Fixing Issues</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 5</strong> | <strong>Reading Time: 17 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>The scientific method for debugging (Ibn al-Haytham's legacy!)</li><li>Mental models for understanding failures</li><li>Debugging tools (print, debugger, profiler, strace)</li><li>Common bug patterns and how to spot them</li><li>The REPL as debugging superpower (Clojure!)</li><li>Why understanding systems beats random guessing</li><li>Debugging as diagnosing the garden's ailments<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9570-processes-programs-in-motion'>9570: Processes</a></strong> - What fails</li><li><strong><a href='/12025-10/9597-testing-verification-validation'>9597: Testing</a></strong> - Finding bugs</li><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - REPL-driven development</li><li><strong><a href='/12025-10/9505-house-of-wisdom-knowledge-gardens'>9505: House of Wisdom</a></strong> - Ibn al-Haytham's scientific method<h2></h2></li></ul><h2>The Scientific Method for Debugging</h2><p><strong>Ibn al-Haytham</strong> (Essay 9505) pioneered the <strong>scientific method</strong> (10th century):</p><ol><li><strong>Observe</strong> (what's broken?)</li><li><strong>Hypothesize</strong> (why might it be broken?)</li><li><strong>Experiment</strong> (test hypothesis)</li><li><strong>Conclude</strong> (was hypothesis correct?)</li><li><strong>Iterate</strong> (if wrong, new hypothesis)</li></ol><p><strong>This is debugging!</strong></p><p><strong>Example</strong>:</p><p><strong>Observe</strong>: \"Server returns 500 error\"</p><p><strong>Hypothesize</strong>: \"Maybe database connection failed?\"</p><p><strong>Experiment</strong>: Check logs:<pre><code class=\"bash\">tail /var/log/app.log\n# Error: Connection refused to localhost:5432\n</code></pre></p><p><strong>Conclude</strong>: Yes, database isn't running!</p><p><strong>Fix</strong>: Start database.</p><p><strong>Plant lens</strong>: <strong>\"Debugging is diagnosing the garden‚Äîobserve symptoms (yellowing leaves), hypothesize cause (nitrogen deficiency?), test (soil sample), treat (add compost).\"</strong><h2></h2></p><h2>Mental Models</h2><p><strong>Understanding the system</strong> beats random guessing:</p><h3>Model 1: The Stack</h3><p><strong>When program crashes</strong>, where?</p><pre><code>Your Code\n    ‚Üì calls\nLibrary A\n    ‚Üì calls\nLibrary B\n    ‚Üì calls\nOperating System\n    ‚Üì calls\nHardware\n</code></pre><p><strong>Error could be anywhere!</strong></p><p><strong>Strategy</strong>: Work backwards (check your code, then libraries, then OS).</p><h3>Model 2: The Data Flow</h3><p><strong>Where does data transform?</strong></p><pre><code>User Input ‚Üí Validation ‚Üí Processing ‚Üí Database ‚Üí Response\n</code></pre><p><strong>Bug location</strong>:</p><ul><li>User input corrupted? (Validation failed)</li><li>Processing wrong? (Logic bug)</li><li>Database error? (SQL issue, connection problem)</li></ul><p><strong>Strategy</strong>: Trace data through pipeline (print at each stage).</p><h3>Model 3: The State Machine</h3><p><strong>Program has states</strong>:</p><pre><code>States: Idle ‚Üí Loading ‚Üí Ready ‚Üí Error\nTransitions: start&#40;&#41; ‚Üí load&#40;&#41; ‚Üí ready&#40;&#41; ‚Üí fail&#40;&#41;\n</code></pre><p><strong>Bug</strong>: Unexpected state transition.</p><p><strong>Strategy</strong>: Log state changes, find illegal transition.<h2></h2></p><h2>Debugging Tools</h2><h3>Printf Debugging (Simplest!)</h3><pre><code class=\"clojure\">&#40;defn mysterious-function &#91;x&#93;\n  &#40;println &quot;DEBUG: x =&quot; x&#41;  ; Print value!\n  &#40;let &#91;result &#40;&#42; x x&#41;&#93;\n    &#40;println &quot;DEBUG: result =&quot; result&#41;\n    result&#41;&#41;\n\n; Output:\n; DEBUG: x = 5\n; DEBUG: result = 25\n</code></pre><p><strong>Pros</strong>: Simple, works everywhere<br /> <strong>Cons</strong>: Clutters code, manual cleanup</p><p><strong>Better</strong>: Use logging library (can disable in production).</p><h3>Interactive Debugger</h3><p><strong>Set breakpoints</strong>, inspect state:</p><pre><code class=\"python\">import pdb\n\ndef buggy&#95;function&#40;x&#41;:\n    y = x &#42; 2\n    pdb.set&#95;trace&#40;&#41;  # STOP HERE!\n    z = y / 0  # Bug!\n    return z\n\n# When you run, program stops at breakpoint\n# You can inspect: x, y, etc.\n# Commands: n &#40;next&#41;, s &#40;step&#41;, c &#40;continue&#41;, p &#40;print&#41;\n</code></pre><p><strong>Pros</strong>: Interactive, can inspect everything<br /> <strong>Cons</strong>: Slower than print debugging for simple cases</p><h3>REPL (Clojure Superpower!)</h3><p><strong>Test code interactively</strong>:</p><pre><code class=\"clojure\">;; In REPL\n&#40;defn process-data &#91;items&#93;\n  &#40;map #&#40;&#42; % 2&#41; items&#41;&#41;\n\n;; Test immediately\n&#40;process-data &#91;1 2 3&#93;&#41;\n;; =&gt; &#40;2 4 6&#41;\n\n;; Modify\n&#40;defn process-data &#91;items&#93;\n  &#40;map #&#40;+ % 10&#41; items&#41;&#41;  ; Changed!\n\n;; Test again &#40;instant feedback!&#41;\n&#40;process-data &#91;1 2 3&#93;&#41;\n;; =&gt; &#40;11 12 13&#41;\n</code></pre><p><strong>No recompile, no restart!</strong> (Essay 9504 - REPL-driven development)</p><h3>System Call Tracing</h3><p><strong>See what program does</strong> (system calls):</p><pre><code class=\"bash\"># Linux\nstrace ls\n# Output: Every system call &#40;open, read, write, close, ...&#41;\n\n# macOS\ndtruss ls\n# &#40;Requires sudo&#41;\n</code></pre><p><strong>Use case</strong>: \"Why is this slow?\" (Trace shows 1000s of file opens!)</p><h3>Profiler</h3><p><strong>Find performance bottlenecks</strong>:</p><pre><code class=\"bash\"># Python\npython -m cProfile slow&#95;script.py\n# Shows: Which functions take most time\n\n# Or:\nimport cProfile\ncProfile.run&#40;'main&#40;&#41;'&#41;\n</code></pre><p><strong>Output</strong>: Function call counts, cumulative time.</p><p><strong>Reveals</strong>: \"90% of time in one function‚Äîoptimize THAT!\"<h2></h2></p><h2>Common Bug Patterns</h2><h3>Off-by-One</h3><pre><code class=\"python\"># Bug\nfor i in range&#40;len&#40;items&#41;&#41;:\n    print&#40;items&#91;i+1&#93;&#41;  # CRASH on last item!\n\n# Fix\nfor i in range&#40;len&#40;items&#41; - 1&#41;:\n    print&#40;items&#91;i+1&#93;&#41;\n\n# Or better:\nfor i in range&#40;1, len&#40;items&#41;&#41;:\n    print&#40;items&#91;i&#93;&#41;\n</code></pre><h3>Null/None Errors</h3><pre><code class=\"javascript\">const user = getUser&#40;id&#41;;\nconsole.log&#40;user.name&#41;;  // CRASH if user is null!\n\n// Fix\nconst user = getUser&#40;id&#41;;\nif &#40;user&#41; {\n    console.log&#40;user.name&#41;;\n} else {\n    console.log&#40;&quot;User not found&quot;&#41;;\n}\n</code></pre><p><strong>Clojure's advantage</strong>: No null! (Uses <code>nil</code>, but explicit handling).</p><h3>Race Conditions</h3><p><strong>Essay 9593</strong> covered this:</p><pre><code class=\"python\"># Two threads\ncounter += 1  # Not atomic!\n\n# Fix\nwith lock:\n    counter += 1\n</code></pre><p><strong>Hardest to debug</strong> (non-deterministic‚Äîappears/disappears randomly).<h2></h2></p><h2>Debugging Strategies</h2><h3>1. Reproduce First</h3><p><strong>Can't fix</strong> what you can't reproduce.</p><p><strong>Steps</strong>:</p><ol><li>Find minimal example that triggers bug</li><li>Automate (write test that fails)</li><li>Fix (until test passes)</li><li>Commit test (prevent regression!)</li></ol><h3>2. Bisect (Binary Search)</h3><p><strong>Bug appeared recently?</strong> Find which commit introduced it:</p><pre><code class=\"bash\">git bisect start\ngit bisect bad          # Current commit is bad\ngit bisect good abc123  # This old commit was good\n\n# Git checks out middle commit\n# Test: Does bug exist?\ngit bisect bad  # If yes\n# Or:\ngit bisect good  # If no\n\n# Git keeps bisecting until it finds exact commit!\n</code></pre><p><strong>Powerful</strong>: Narrows down from 100 commits to 1 (in ~7 tests).</p><h3>3. Rubber Duck Debugging</h3><p><strong>Explain problem</strong> to rubber duck (or colleague, or yourself):</p><pre><code>&quot;So the server crashes when...\n Wait, I'm sending a string but it expects an integer!\n That's the bug!&quot;\n</code></pre><p><strong>Often</strong>: Explaining the problem <strong>reveals the solution</strong>.</p><h3>4. Read Error Messages</h3><p><strong>They tell you what's wrong!</strong></p><pre><code>Traceback &#40;most recent call last&#41;:\n  File &quot;app.py&quot;, line 42, in process\n    result = items&#91;10&#93;\nIndexError: list index out of range\n\n&#94;-- Line 42, accessing index 10, but list too short!\n</code></pre><p><strong>Don't ignore errors</strong> (read carefully, they're helpful!).<h2></h2></p><h2>The REPL Advantage</h2><p><strong>Clojure's REPL</strong> (Essay 9504) makes debugging <strong>interactive</strong>:</p><pre><code class=\"clojure\">;; Function is broken\n&#40;defn broken &#91;data&#93;\n  &#40;map :value data&#41;&#41;  ; Assumes data is collection of maps\n\n;; Test in REPL\n&#40;broken &#91;{:value 1} {:value 2}&#93;&#41;\n;; =&gt; &#40;1 2&#41;  Works!\n\n&#40;broken nil&#41;\n;; =&gt; NullPointerException  AHA!\n\n;; Fix\n&#40;defn fixed &#91;data&#93;\n  &#40;map :value &#40;or data &#91;&#93;&#41;&#41;&#41;  ; Handle nil\n\n;; Test immediately\n&#40;fixed nil&#41;\n;; =&gt; &#40;&#41;  Works!\n</code></pre><p><strong>Instant feedback loop</strong> (no recompile, no restart).</p><p><strong>This is why</strong> dynamic languages (Clojure, Python, JavaScript) are popular for exploration.<h2></h2></p><h2>Try This</h2><h3>Exercise 1: Printf Debugging</h3><pre><code class=\"python\">def mystery&#95;bug&#40;items&#41;:\n    result = &#91;&#93;\n    for item in items:\n        if item &gt; 0:\n            result.append&#40;item &#42; 2&#41;\n    return result\n\n# Test\nprint&#40;mystery&#95;bug&#40;&#91;1, -5, 3, 0, 7&#93;&#41;&#41;\n# Expected: &#91;2, 6, 14&#93;\n# Actual: &#91;2, 6, 14&#93;  &#40;Correct!&#41;\n\nprint&#40;mystery&#95;bug&#40;&#91;&#93;&#41;&#41;\n# Expected: &#91;&#93;\n# Crashes? Or works? &#40;Test edge cases!&#41;\n</code></pre><p><strong>Add prints</strong>:<pre><code class=\"python\">def mystery&#95;bug&#40;items&#41;:\n    print&#40;f&quot;DEBUG: items = {items}&quot;&#41;\n    result = &#91;&#93;\n    for item in items:\n        print&#40;f&quot;DEBUG: processing {item}&quot;&#41;\n        if item &gt; 0:\n            result.append&#40;item &#42; 2&#41;\n    print&#40;f&quot;DEBUG: result = {result}&quot;&#41;\n    return result\n</code></pre></p><h2></h2><h3>Exercise 2: Git Bisect</h3><pre><code class=\"bash\"># Create test repo\nmkdir bisect-test &amp;&amp; cd bisect-test\ngit init\n\n# Create 10 commits\nfor i in {1..10}; do\n    echo &quot;Version $i&quot; &gt; file.txt\n    git add file.txt\n    git commit -m &quot;Version $i&quot;\ndone\n\n# Introduce &quot;bug&quot; in commit 7\ngit checkout HEAD&#126;3  # Go to commit 7\necho &quot;BUG!&quot; &gt;&gt; file.txt\ngit commit --amend -m &quot;Version 7 &#40;with bug&#41;&quot;\ngit checkout main\n\n# Now bisect to find it!\ngit bisect start\ngit bisect bad\ngit bisect good HEAD&#126;9\n\n# Check each commit:\ngrep &quot;BUG&quot; file.txt &amp;&amp; git bisect bad || git bisect good\n\n# Git finds commit 7!\n</code></pre><h2></h2><h3>Exercise 3: REPL Exploration</h3><pre><code class=\"clojure\">;; In Clojure REPL\n&#40;defn divide &#91;a b&#93;\n  &#40;/ a b&#41;&#41;\n\n;; Test\n&#40;divide 10 2&#41;\n;; =&gt; 5\n\n&#40;divide 10 0&#41;\n;; =&gt; ArithmeticException: Divide by zero\n\n;; Fix interactively\n&#40;defn safe-divide &#91;a b&#93;\n  &#40;if &#40;zero? b&#41;\n    nil\n    &#40;/ a b&#41;&#41;&#41;\n\n;; Test immediately\n&#40;safe-divide 10 0&#41;\n;; =&gt; nil  &#40;Better!&#41;\n</code></pre><p><strong>Observe</strong>: Immediate feedback (no compilation wait).<h2></h2></p><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9597-testing-verification-validation'>9597: Testing</a></strong> - Finding bugs early</li><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - REPL debugging</li><li><strong><a href='/12025-10/9505-house-of-wisdom-knowledge-gardens'>9505: House of Wisdom</a></strong> - Ibn al-Haytham's method</li><li><strong><a href='/12025-10/9593-concurrency-threads-parallelism'>9593: Concurrency</a></strong> - Race condition debugging</li></ul><h3>External Resources</h3><ul><li><strong>\"Debugging: The 9 Indispensable Rules\"</strong> - David Agans</li><li><strong>GDB Tutorial</strong> - GNU debugger (C/C++)</li><li><strong>pdb documentation</strong> - Python debugger</li><li><strong>Chrome DevTools</strong> - Web debugging<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Is debugging an art or science?</strong> (Scientific method + intuition‚Äîboth!)</li><li><strong>Why do some bugs only appear in production?</strong> (Environment differences, race conditions, scale)</li><li><strong>Should all bugs be fixed immediately?</strong> (Triage - critical vs minor, fix now vs defer)</li><li><strong>Can formal verification eliminate debugging?</strong> (seL4 has zero bugs‚Äîbut 11 person-years to verify!)</li><li><strong>How would Nock programs be debugged?</strong> (Pure functions (noun ‚Üí noun) - deterministic, traceable!)<h2></h2></li></ol><h2>Summary</h2><p><strong>Debugging is</strong>:</p><ul><li><strong>Scientific process</strong> (Ibn al-Haytham's method!)</li><li><strong>Hypothesis-driven</strong> (guess ‚Üí test ‚Üí refine)</li><li><strong>Systematic</strong> (not random guessing)</li></ul><p><strong>Mental Models</strong>:</p><ul><li><strong>The Stack</strong>: Work backwards (your code ‚Üí libraries ‚Üí OS)</li><li><strong>Data Flow</strong>: Trace transformations (input ‚Üí pipeline ‚Üí output)</li><li><strong>State Machine</strong>: Track state transitions (find illegal ones)</li></ul><p><strong>Tools</strong>:</p><ul><li><strong>Printf</strong>: Simple, universal (add prints, observe)</li><li><strong>Debugger</strong>: Interactive (breakpoints, inspect state)</li><li><strong>REPL</strong>: Immediate feedback (Clojure superpower!)</li><li><strong>strace/dtruss</strong>: System call tracing (see what program does)</li><li><strong>Profiler</strong>: Find bottlenecks (which function is slow)</li></ul><p><strong>Common Patterns</strong>:</p><ul><li><strong>Off-by-one</strong>: Array indexing errors</li><li><strong>Null errors</strong>: Missing null checks</li><li><strong>Race conditions</strong>: Concurrent access to shared state</li></ul><p><strong>Strategies</strong>:</p><ul><li><strong>Reproduce first</strong>: Can't fix what you can't trigger</li><li><strong>Bisect</strong>: Binary search through commits (git bisect)</li><li><strong>Rubber duck</strong>: Explain to someone (reveals solution!)</li><li><strong>Read errors</strong>: They tell you what's wrong!</li></ul><p><strong>REPL Advantage</strong>:</p><ul><li><strong>Interactive testing</strong> (no recompile!)</li><li><strong>Immediate feedback</strong> (edit ‚Üí test ‚Üí refine)</li><li><strong>Exploration</strong> (try things, see results)</li><li><strong>Why Clojure wins</strong> for exploratory programming</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>We use scientific method</strong> (observe, hypothesize, test)</li><li><strong>We prefer REPLs</strong> (immediate feedback loop)</li><li><strong>We write tests</strong> (prevent regressions)</li><li><strong>We understand systems</strong> (mental models > guessing)</li></ul><p><strong>Plant lens</strong>: <strong>\"Debugging is diagnosing garden ailments‚Äîobserve symptoms (yellow leaves), hypothesize (nitrogen?), test (soil sample), treat (compost), verify (leaves green again).\"</strong><h2></h2></p><p><strong>Next</strong>: <strong>Essay 9600 - Phase 1 Synthesis!</strong> We'll tie together everything you've learned in the first 100 essays and prepare you for Phase 2!<h2></h2></p><p><strong>Navigation</strong>:<br /> ‚Üê Previous: <a href='/12025-10/9599-documentation-writing-for-humans'>9599 (documentation writing for humans)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9601-phase-1-synthesis-foundations-laid'>9601 (phase 1 synthesis foundations laid)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 5</li><li><strong>Prerequisites</strong>: 9570, 9597, 9504, 9505</li><li><strong>Concepts</strong>: Debugging, scientific method, mental models, tools (printf, debugger, REPL, strace, profiler)</li><li><strong>Next Concepts</strong>: Phase 1 synthesis, integration, next steps</li><li><strong>Plant Lens</strong>: Diagnosing ailments, observing symptoms, testing hypotheses, treating causes</li><li><strong>Wisdom Tradition</strong>: üåô Islamic (Ibn al-Haytham's scientific method applied to debugging!)</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright ¬© 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.429663547Z-13096"
}