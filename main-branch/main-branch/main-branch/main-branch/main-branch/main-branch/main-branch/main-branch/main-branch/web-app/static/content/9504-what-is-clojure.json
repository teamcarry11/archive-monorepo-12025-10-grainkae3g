{
  "slug" : "9504-what-is-clojure",
  "meta" : {
    "slug" : "9504-what-is-clojure",
    "title" : "kae3g 9504: What Is Clojure? A Practical Lisp for the JVM",
    "filename" : "9504-what-is-clojure.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9504: What Is Clojure? A Practical Lisp for the JVM</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 1</strong> | <strong>Reading Time: 16 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>Clojure: A modern Lisp bringing functional programming to mainstream platforms</li><li>Why \"code as data\" (homoiconicity) is powerful</li><li>Immutable data structures and why they matter</li><li>The REPL workflow: interactive development</li><li>How Clojure relates to Java, JavaScript, and the Lisp family</li><li>Rich Hickey's design philosophy: \"Simple Made Easy\"</li><li>Practical code examples you can run today<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9500-what-is-a-computer'>9500: What Is a Computer?</a></strong> - Computational foundations</li><li><strong><a href='/12025-10/9503-what-is-nock'>9503: What Is Nock?</a></strong> - Minimal computation (for contrast)</li></ul><p>Optional:</p><ul><li><strong><a href='/12025-10/9502-ode-to-nocturnal-time'>9502: Ode to Nocturnal Time</a></strong> - Many Clojure breakthroughs happen at 2 AM!<h2></h2></li></ul><h2>The Pragmatic Lisp</h2><p><strong>Nock</strong> (Essay 9503) showed us <strong>radical minimalism</strong>: 12 rules, eternal spec, auditable simplicity.</p><p><strong>Clojure</strong> shows us <strong>pragmatic minimalism</strong>: Simple philosophy + practical platform + real-world adoption.</p><blockquote><p> <strong>Clojure</strong> (2007) by Rich Hickey: A Lisp for the JVM that embraces hosted platforms, immutability, and simplicity. </p></blockquote><p><strong>The balance</strong>:</p><ul><li><strong>Simple</strong> like Lisp (data-oriented, functional)</li><li><strong>Practical</strong> like Java (mature platform, huge ecosystem)</li><li><strong>Modern</strong> (designed for concurrency, immutability-first)<h2></h2></li></ul><h2>Lisp: Code as Data (Homoiconicity)</h2><p><strong>The central insight</strong> of Lisp (1958, John McCarthy):</p><blockquote><p> <strong>Code is data. Data is code. They're the same thing.</strong> </p></blockquote><h3>In Most Languages</h3><p><strong>Code</strong>:<pre><code class=\"python\">def add&#40;x, y&#41;:\n    return x + y\n</code></pre></p><p><strong>Data</strong>:<pre><code class=\"python\">&#91;1, 2, 3&#93;\n</code></pre></p><p>Code and data are <strong>different</strong>. You can't easily manipulate code as data.</p><h3>In Lisp (and Clojure)</h3><p><strong>Code</strong>:<pre><code class=\"clojure\">&#40;defn add &#91;x y&#93;\n  &#40;+ x y&#41;&#41;\n</code></pre></p><p><strong>Data</strong>:<pre><code class=\"clojure\">&#91;1 2 3&#93;\n</code></pre></p><p>Both are <strong>S-expressions</strong> (symbolic expressions)—lists of atoms and nested lists.</p><p><strong>The code IS a list</strong>: <code>&#40;defn add &#91;x y&#93; &#40;+ x y&#41;&#41;</code></p><p>You can:</p><ul><li>Build code at runtime (as data)</li><li>Transform code (like any data structure)</li><li>Execute data as code (eval)</li><li>Write code that writes code (macros)</li></ul><p><strong>This is homoiconicity</strong>: The language's syntax is <strong>its own data structure</strong>.<h2></h2></p><h2>Clojure in 5 Minutes</h2><h3>1. Everything Is an Expression</h3><pre><code class=\"clojure\">;; Numbers\n42                    ; =&gt; 42\n\n;; Strings\n&quot;hello valley&quot;        ; =&gt; &quot;hello valley&quot;\n\n;; Keywords &#40;like symbols/atoms in other languages&#41;\n:name                 ; =&gt; :name\n\n;; Lists &#40;code!&#41;\n&#40;+ 1 2&#41;              ; =&gt; 3\n\n;; Vectors &#40;ordered collections&#41;\n&#91;1 2 3&#93;              ; =&gt; &#91;1 2 3&#93;\n\n;; Maps &#40;key-value pairs&#41;\n{:name &quot;Clojure&quot;\n :year 2007\n :paradigm :functional}  ; =&gt; {:name &quot;Clojure&quot;, :year 2007, :paradigm :functional}\n\n;; Sets\n#{1 2 3}             ; =&gt; #{1 3 2} &#40;unordered&#41;\n</code></pre><p><strong>Everything evaluates to something.</strong> No statements—only expressions.</p><h3>2. Functions</h3><pre><code class=\"clojure\">;; Define a function\n&#40;defn greet &#91;name&#93;\n  &#40;str &quot;Hello, &quot; name &quot;!&quot;&#41;&#41;\n\n;; Call it\n&#40;greet &quot;Valley Builder&quot;&#41;  ; =&gt; &quot;Hello, Valley Builder!&quot;\n\n;; Functions are first-class &#40;pass them around&#41;\n&#40;map greet &#91;&quot;Alice&quot; &quot;Bob&quot; &quot;Carol&quot;&#93;&#41;\n; =&gt; &#40;&quot;Hello, Alice!&quot; &quot;Hello, Bob!&quot; &quot;Hello, Carol!&quot;&#41;\n</code></pre><p><strong>Prefix notation</strong> (the Lisp way):</p><ul><li>Math: <code>&#40;+ 1 2 3&#41;</code> not <code>1 + 2 + 3</code></li><li>Calls: <code>&#40;func arg1 arg2&#41;</code> not <code>func&#40;arg1, arg2&#41;</code></li></ul><p><strong>Why?</strong> Consistency. Everything is <code>&#40;operator operands...&#41;</code>. No special cases.</p><h3>3. Immutability</h3><pre><code class=\"clojure\">;; Create a vector\n&#40;def v &#91;1 2 3&#93;&#41;\n\n;; &quot;Add&quot; an element &#40;creates NEW vector, old unchanged&#41;\n&#40;conj v 4&#41;           ; =&gt; &#91;1 2 3 4&#93;\n\n;; Original is unchanged!\nv                    ; =&gt; &#91;1 2 3&#93;\n\n;; To &quot;update&quot;, rebind the name\n&#40;def v &#40;conj v 4&#41;&#41;\nv                    ; =&gt; &#91;1 2 3 4&#93;\n</code></pre><p><strong>Values never change.</strong> You create <strong>new values</strong> instead.</p><p><strong>Why this matters</strong>:</p><ul><li><strong>No spooky action at a distance</strong> (calling a function can't break your data)</li><li><strong>Thread-safe by default</strong> (immutable data = no race conditions)</li><li><strong>Time travel debugging</strong> (keep old values, inspect past states)</li><li><strong>Easier reasoning</strong> (value is always what it was)</li></ul><h3>4. The REPL (Read-Eval-Print Loop)</h3><pre><code class=\"clojure\">;; In a Clojure REPL:\n\nuser=&gt; &#40;+ 1 2&#41;\n3\n\nuser=&gt; &#40;defn factorial &#91;n&#93;\n         &#40;if &#40;&lt;= n 1&#41;\n           1\n           &#40;&#42; n &#40;factorial &#40;dec n&#41;&#41;&#41;&#41;&#41;\n#'user/factorial\n\nuser=&gt; &#40;factorial 5&#41;\n120\n\nuser=&gt; &#40;map factorial &#91;1 2 3 4 5&#93;&#41;\n&#40;1 2 6 24 120&#41;\n</code></pre><p><strong>The REPL is interactive programming</strong>:</p><ol><li>Write an expression</li><li>Evaluate it immediately</li><li>See the result</li><li>Refine and iterate</li></ol><p><strong>No compile-wait-run cycle.</strong> Instant feedback. <strong>This changes how you think.</strong></p><h3>5. Host Interop (JVM)</h3><pre><code class=\"clojure\">;; Call Java from Clojure\n&#40;import java.time.LocalDateTime&#41;\n\n&#40;def now &#40;LocalDateTime/now&#41;&#41;\n; =&gt; #object&#91;java.time.LocalDateTime &quot;2025-10-10T23:47:13.123&quot;&#93;\n\n&#40;.toString now&#41;\n; =&gt; &quot;2025-10-10T23:47:13.123&quot;\n\n;; All of Java's libraries available!\n</code></pre><p><strong>Clojure runs on the JVM</strong>, giving you:</p><ul><li><strong>Mature platform</strong> (30 years of optimization)</li><li><strong>Vast ecosystem</strong> (every Java library is usable)</li><li><strong>Production-ready</strong> (battle-tested in finance, web, data)</li></ul><p><strong>ClojureScript</strong> is the same language compiled to <strong>JavaScript</strong> (runs in browsers, Node.js).<h2></h2></p><h2>Immutability: The Superpower</h2><p><strong>Most languages</strong>: Variables <strong>vary</strong>.</p><pre><code class=\"javascript\">let x = 10;\nx = x + 1;  // x is now 11 &#40;mutated&#41;\n</code></pre><p><strong>Clojure</strong>: Values are <strong>immutable</strong>.</p><pre><code class=\"clojure\">&#40;def x 10&#41;\n&#40;def x &#40;+ x 1&#41;&#41;  ; Creates NEW binding, doesn't mutate\n</code></pre><p><strong>Wait, how do you build programs without mutation?</strong></p><h3>Example: Updating a Map</h3><p><strong>Mutable (JavaScript)</strong>:<pre><code class=\"javascript\">let user = {name: &quot;Alice&quot;, age: 30};\nuser.age = 31;  // Mutated in place\n</code></pre></p><p><strong>Immutable (Clojure)</strong>:<pre><code class=\"clojure\">&#40;def user {:name &quot;Alice&quot; :age 30}&#41;\n&#40;def updated-user &#40;assoc user :age 31&#41;&#41;\n\nuser          ; =&gt; {:name &quot;Alice&quot;, :age 30}  &#40;unchanged!&#41;\nupdated-user  ; =&gt; {:name &quot;Alice&quot;, :age 31}  &#40;new value&#41;\n</code></pre></p><p><strong>\"But isn't that inefficient? Copying the whole map?\"</strong></p><p><strong>No!</strong> Clojure uses <strong>persistent data structures</strong> (structural sharing):</p><pre><code>Original:  {:name &quot;Alice&quot; :age 30}\n                    ↓ &#40;shares structure&#41;\nUpdated:   {:name &quot;Alice&quot; :age 31}\n\nOnly the CHANGED part is new. The rest is shared.\nPerformance: O&#40;log n&#41; updates, not O&#40;n&#41; copying!\n</code></pre><p><strong>This is engineering brilliance</strong>: Immutability <strong>with</strong> performance.<h2></h2></p><h2>The REPL-Driven Development</h2><p><strong>Traditional workflow</strong>:</p><pre><code>1. Write code\n2. Compile\n3. Run\n4. See output\n5. Edit code\n6. Recompile &#40;wait...&#41;\n7. Run again\n8. Repeat\n</code></pre><p><strong>Clojure workflow</strong>:</p><pre><code>1. Start REPL\n2. Write function\n3. Eval it &#40;instant!&#41;\n4. Test it &#40;in same REPL&#41;\n5. Refine it &#40;eval again&#41;\n6. Build entire program incrementally\n7. REPL session IS your development\n</code></pre><p><strong>No compile-wait cycle.</strong> Changes are <strong>instant</strong>.</p><h3>Example Session</h3><pre><code class=\"clojure\">;; Start with a sketch\nuser=&gt; &#40;defn greet &#91;name&#93;\n         &#40;str &quot;Hi &quot; name&#41;&#41;\n\nuser=&gt; &#40;greet &quot;Alice&quot;&#41;\n&quot;Hi Alice&quot;\n\n;; Refine &#40;add punctuation&#41;\nuser=&gt; &#40;defn greet &#91;name&#93;\n         &#40;str &quot;Hi, &quot; name &quot;!&quot;&#41;&#41;\n\nuser=&gt; &#40;greet &quot;Alice&quot;&#41;\n&quot;Hi, Alice!&quot;\n\n;; Extend &#40;handle nil&#41;\nuser=&gt; &#40;defn greet &#91;name&#93;\n         &#40;if name\n           &#40;str &quot;Hi, &quot; name &quot;!&quot;&#41;\n           &quot;Hi, stranger!&quot;&#41;&#41;\n\nuser=&gt; &#40;greet nil&#41;\n&quot;Hi, stranger!&quot;\n\n;; Perfect! Now save to file.\n</code></pre><p><strong>You built the function interactively</strong>, testing each iteration immediately.</p><p><strong>This is how Lisp programmers have worked since 1958.</strong> Clojure brings it to modern platforms.<h2></h2></p><h2>Rich Hickey's Philosophy: \"Simple Made Easy\"</h2><p><strong>Rich Hickey</strong> (Clojure's creator) gave a seminal talk: <a href='https://www.infoq.com/presentations/Simple-Made-Easy/'>\"Simple Made Easy\"</a> (2011).</p><p><strong>Core distinction</strong>:</p><p><strong>Simple</strong> (from <em>simplex</em> - \"one fold/braid\"):</p><ul><li><strong>One role, one task, one concept</strong></li><li>Not compound, not intertwined</li><li>Objectively measurable</li></ul><p><strong>Easy</strong> (from <em>adjacent</em> - \"near at hand\"):</p><ul><li><strong>Familiar, convenient</strong></li><li>Subjectively experienced</li><li>Can be simple OR complex</li></ul><p><strong>Example</strong>:</p><table><thead><tr><th>Tool</th><th>Simple?</th><th>Easy?</th></tr></thead><tbody><tr><td><code>make</code></td><td>No (complects building + dependency tracking + shell scripting)</td><td>Yes (familiar to Unix users)</td></tr><tr><td>Nix</td><td>Yes (pure functions, no hidden state)</td><td>No (unfamiliar paradigm)</td></tr><tr><td>Maven</td><td>No (XML config + build lifecycle + plugins all tangled)</td><td>Yes (lots of tutorials)</td></tr></tbody></table><p><strong>Hickey's argument</strong>: We confuse \"easy\" (familiar) with \"simple\" (not intertwined).</p><p><strong>Clojure prioritizes SIMPLE</strong>:</p><ul><li>Immutable by default (not intertwined with time)</li><li>Functions without side effects (not intertwined with global state)</li><li>Data literals (not intertwined with classes/objects)</li><li>Hosted (not intertwined with its own runtime—uses JVM/JS)<h2></h2></li></ul><h2>Clojure's Core Principles</h2><h3>1. Immutability</h3><p><strong>Already covered</strong>, but worth repeating: <strong>Values don't change.</strong></p><p><strong>Benefits</strong>:</p><ul><li><strong>Fearless concurrency</strong> (immutable data = no locks needed)</li><li><strong>Easier debugging</strong> (values don't change under you)</li><li><strong>Time-travel</strong> (keep old versions, inspect history)</li></ul><h3>2. First-Class Functions</h3><p><strong>Functions are values</strong> (can be passed, returned, stored):</p><pre><code class=\"clojure\">;; Function as argument\n&#40;defn apply-twice &#91;f x&#93;\n  &#40;f &#40;f x&#41;&#41;&#41;\n\n&#40;apply-twice inc 5&#41;  ; =&gt; 7  &#40;inc twice: 5 → 6 → 7&#41;\n\n;; Function as return value\n&#40;defn make-adder &#91;n&#93;\n  &#40;fn &#91;x&#93; &#40;+ x n&#41;&#41;&#41;\n\n&#40;def add10 &#40;make-adder 10&#41;&#41;\n&#40;add10 5&#41;  ; =&gt; 15\n</code></pre><p><strong>Higher-order functions</strong> enable powerful abstractions (map, filter, reduce).</p><h3>3. Code as Data (Homoiconicity)</h3><p><strong>Clojure code is Clojure data</strong>:</p><pre><code class=\"clojure\">;; This is code:\n&#40;+ 1 2&#41;\n\n;; This is also data &#40;a list&#41;:\n'&#40;+ 1 2&#41;  ; Quote prevents evaluation\n\n;; Manipulate code as data:\n&#40;first '&#40;+ 1 2&#41;&#41;   ; =&gt; +\n&#40;rest '&#40;+ 1 2&#41;&#41;    ; =&gt; &#40;1 2&#41;\n\n;; Build code at runtime:\n&#40;def code-to-run '&#40;+ 1 2&#41;&#41;\n&#40;eval code-to-run&#41;  ; =&gt; 3\n</code></pre><p><strong>Macros</strong> exploit this:</p><pre><code class=\"clojure\">;; Macro: transform code before evaluation\n&#40;defmacro when-positive &#91;n &amp; body&#93;\n  `&#40;if &#40;pos? &#126;n&#41;\n     &#40;do &#126;@body&#41;&#41;&#41;\n\n;; Expands to:\n&#40;when-positive 5\n  &#40;println &quot;positive!&quot;&#41;\n  &#40;println &quot;doing work&quot;&#41;&#41;\n\n; Becomes:\n&#40;if &#40;pos? 5&#41;\n  &#40;do\n    &#40;println &quot;positive!&quot;&#41;\n    &#40;println &quot;doing work&quot;&#41;&#41;&#41;\n</code></pre><p><strong>Macros are code that writes code.</strong> This is <strong>metaprogramming</strong> at the language level.</p><h3>4. Hosted on the JVM (and JavaScript)</h3><p><strong>Clojure doesn't fight its platform</strong>—it embraces it:</p><pre><code class=\"clojure\">;; Use Java libraries seamlessly\n&#40;import java.util.Date&#41;\n&#40;def now &#40;Date.&#41;&#41;\n\n;; Use Clojure idioms on Java objects\n&#40;.getTime now&#41;  ; =&gt; 1728604033123\n\n;; Mix freely\n&#40;defn days-until &#91;target-date&#93;\n  &#40;let &#91;now &#40;Date.&#41;\n        diff &#40;- &#40;.getTime target-date&#41; &#40;.getTime now&#41;&#41;&#93;\n    &#40;/ diff &#40;&#42; 1000 60 60 24&#41;&#41;&#41;&#41;\n</code></pre><p><strong>ClojureScript</strong> does the same for JavaScript:</p><pre><code class=\"clojure\">;; ClojureScript in browser\n&#40;ns my-app.core\n  &#40;:require &#91;reagent.core :as r&#93;&#41;&#41;\n\n&#40;defn hello &#91;&#93;\n  &#91;:div &quot;Hello from ClojureScript!&quot;&#93;&#41;\n\n&#40;r/render &#91;hello&#93; &#40;.getElementById js/document &quot;app&quot;&#41;&#41;\n</code></pre><p><strong>Benefits of hosting</strong>:</p><ul><li><strong>Mature platform</strong> (JVM is 30 years old, battle-tested)</li><li><strong>Vast ecosystem</strong> (Java has millions of libraries)</li><li><strong>Production-ready</strong> (companies trust the JVM)</li><li><strong>Cross-platform</strong> (JVM runs everywhere)</li></ul><p><strong>Trade-off</strong>: You're dependent on the host (JVM startup time, JavaScript quirks). But Clojure's philosophy: <strong>embrace the platform, don't fight it</strong>.</p><h3>5. Interactive Development (The REPL)</h3><p><strong>The REPL is central</strong> to Clojure workflow:</p><pre><code class=\"clojure\">;; Connected to running application\nuser=&gt; &#40;def users &#40;atom &#91;&#93;&#41;&#41;\n\nuser=&gt; &#40;swap! users conj {:name &quot;Alice&quot;}&#41;\n&#91;{:name &quot;Alice&quot;}&#93;\n\n;; Add validation\nuser=&gt; &#40;defn add-user &#91;db user&#93;\n         &#40;if &#40;:name user&#41;\n           &#40;conj db user&#41;\n           db&#41;&#41;\n\nuser=&gt; &#40;swap! users add-user {:name &quot;Bob&quot;}&#41;\n&#91;{:name &quot;Alice&quot;} {:name &quot;Bob&quot;}&#93;\n\n;; Test edge cases\nuser=&gt; &#40;swap! users add-user {}&#41;  ; No name\n&#91;{:name &quot;Alice&quot;} {:name &quot;Bob&quot;}&#93;  ; Unchanged &#40;validation worked&#41;\n</code></pre><p><strong>You're testing against LIVE data</strong> in your running app. Instant feedback. <strong>This changes everything.</strong><h2></h2></p><h2>Clojure vs Other Lisps</h2><h3>Common Lisp (1984)</h3><p><strong>Pros</strong>: Mature, powerful, standardized<br /> <strong>Cons</strong>: Complex (CLOS object system, 1,000-page spec), isolated ecosystem</p><p><strong>Clojure's improvement</strong>: Simpler (no CLOS), hosted (JVM ecosystem)</p><h3>Scheme (1975)</h3><p><strong>Pros</strong>: Minimal, elegant, educational<br /> <strong>Cons</strong>: Too minimal for production, fragmented implementations</p><p><strong>Clojure's improvement</strong>: More practical (richer core library), unified (one canonical implementation)</p><h3>Racket (1995, Scheme descendant)</h3><p><strong>Pros</strong>: Excellent for education, rich IDE support<br /> <strong>Cons</strong>: Smaller ecosystem, less production use</p><p><strong>Clojure's improvement</strong>: Production-focused, huge ecosystem (via JVM)</p><h3>Emacs Lisp</h3><p><strong>Pros</strong>: Scriptable editor, huge community<br /> <strong>Cons</strong>: Single-threaded, old design, Emacs-specific</p><p><strong>Clojure's improvement</strong>: Modern (concurrency-first), general-purpose, multiplatform</p><p><strong>Summary</strong>: Clojure is <strong>Lisp for 2007+</strong>—learning from decades of Lisp experience, optimized for real-world use.<h2></h2></p><h2>Practical Examples</h2><h3>Example 1: Transforming Data</h3><p><strong>Problem</strong>: Given a list of users, extract names.</p><p><strong>JavaScript</strong>:<pre><code class=\"javascript\">const users = &#91;{name: &quot;Alice&quot;, age: 30}, {name: &quot;Bob&quot;, age: 25}&#93;;\nconst names = users.map&#40;u =&gt; u.name&#41;;\n// =&gt; &#91;&quot;Alice&quot;, &quot;Bob&quot;&#93;\n</code></pre></p><p><strong>Clojure</strong>:<pre><code class=\"clojure\">&#40;def users &#91;{:name &quot;Alice&quot; :age 30} {:name &quot;Bob&quot; :age 25}&#93;&#41;\n&#40;map :name users&#41;\n; =&gt; &#40;&quot;Alice&quot; &quot;Bob&quot;&#41;\n</code></pre></p><p><strong>Notice</strong>: <code>:name</code> is a <strong>function</strong> that gets the <code>:name</code> key from a map. Keywords are functions!</p><h3>Example 2: Filtering</h3><p><strong>Problem</strong>: Find users over 25.</p><p><strong>Clojure</strong>:<pre><code class=\"clojure\">&#40;filter #&#40;&gt; &#40;:age %&#41; 25&#41; users&#41;\n; =&gt; &#40;{:name &quot;Alice&quot;, :age 30}&#41;\n\n;; Or more readable:\n&#40;filter &#40;fn &#91;user&#93; &#40;&gt; &#40;:age user&#41; 25&#41;&#41; users&#41;\n</code></pre></p><p><code>#&#40;...&#41;</code> is shorthand for anonymous functions: <code>#&#40;&gt; &#40;:age %&#41; 25&#41;</code> = <code>&#40;fn &#91;x&#93; &#40;&gt; &#40;:age x&#41; 25&#41;&#41;</code></p><h3>Example 3: Threading (Composition)</h3><p><strong>Problem</strong>: Transform data through multiple steps.</p><p><strong>Nested (hard to read)</strong>:<pre><code class=\"clojure\">&#40;reduce + &#40;map :age &#40;filter #&#40;&gt; &#40;:age %&#41; 25&#41; users&#41;&#41;&#41;\n; Read inside-out: filter, then map, then reduce\n</code></pre></p><p><strong>Threaded (clear pipeline)</strong>:<pre><code class=\"clojure\">&#40;-&gt;&gt; users\n     &#40;filter #&#40;&gt; &#40;:age %&#41; 25&#41;&#41;\n     &#40;map :age&#41;\n     &#40;reduce +&#41;&#41;\n; Read top-to-bottom: filter, then map, then reduce\n</code></pre></p><p><strong>The <code>-&gt;&gt;</code> macro</strong> threads each result as <strong>last argument</strong> to next function.</p><p><strong>Result</strong>: Same computation, but reads like <strong>a pipeline</strong> (water flowing through stages).</p><h3>Example 4: Building a Web Server</h3><p><strong>Clojure + Ring (web library)</strong>:</p><pre><code class=\"clojure\">&#40;ns my-server.core\n  &#40;:require &#91;ring.adapter.jetty :as jetty&#93;&#41;&#41;\n\n&#40;defn handler &#91;request&#93;\n  {:status 200\n   :headers {&quot;Content-Type&quot; &quot;text/plain&quot;}\n   :body &quot;Hello from Clojure!&quot;}&#41;\n\n&#40;defn -main &#91;&#93;\n  &#40;jetty/run-jetty handler {:port 3000}&#41;&#41;\n\n;; Run: &#40;main&#41;\n;; Visit: http://localhost:3000\n</code></pre><p><strong>That's it.</strong> A function that takes a <strong>request</strong> (map) and returns a <strong>response</strong> (map).</p><p><strong>No framework ceremony.</strong> Just <strong>data in, data out.</strong><h2></h2></p><h2>Simple Made Easy: The Design Philosophy</h2><p><strong>Rich Hickey's core thesis</strong>:</p><blockquote><p> \"We should aim for simplicity, because simplicity is a prerequisite for reliability.\" - Dijkstra </p></blockquote><p><strong>How Clojure embodies simplicity</strong>:</p><h3>1. Separate Identity and State</h3><p><strong>Complex</strong>: Object-oriented (identity and state bundled together)</p><pre><code class=\"java\">// Java: object has mutable state\nUser user = new User&#40;&quot;Alice&quot;&#41;;\nuser.setAge&#40;31&#41;;  // Mutated—identity same, state changed\n</code></pre><p><strong>Simple</strong>: Clojure separates them</p><pre><code class=\"clojure\">;; Values &#40;state&#41; are immutable\n&#40;def alice-v1 {:name &quot;Alice&quot; :age 30}&#41;\n&#40;def alice-v2 &#40;assoc alice-v1 :age 31&#41;&#41;\n\n;; Identity &#40;if needed&#41; managed explicitly\n&#40;def alice &#40;atom {:name &quot;Alice&quot; :age 30}&#41;&#41;\n&#40;swap! alice assoc :age 31&#41;\n</code></pre><p><strong>Benefit</strong>: You <strong>choose</strong> when to conflate identity with state. Not forced.</p><h3>2. No Hidden Coupling</h3><p><strong>Complex</strong>: Global state, singletons, implicit dependencies</p><p><strong>Simple</strong>: Explicit arguments, pure functions</p><pre><code class=\"clojure\">;; Bad &#40;implicit dependency on global&#41;\n&#40;def users &#40;atom &#91;&#93;&#41;&#41;\n\n&#40;defn add-user &#91;name&#93;\n  &#40;swap! users conj {:name name}&#41;&#41;  ; Mutates global—spooky!\n\n;; Good &#40;explicit dependency&#41;\n&#40;defn add-user &#91;db name&#93;\n  &#40;conj db {:name name}&#41;&#41;  ; Pure function—returns new db\n\n;; Call site makes dependency visible\n&#40;swap! users add-user &quot;Alice&quot;&#41;\n</code></pre><h3>3. Data Orientation</h3><p><strong>Complex</strong>: Objects with methods, inheritance hierarchies</p><p><strong>Simple</strong>: Plain data with functions</p><pre><code class=\"clojure\">;; No classes, just data\n&#40;def user {:name &quot;Alice&quot; :age 30 :role :admin}&#41;\n\n;; Functions on data\n&#40;defn admin? &#91;user&#93;\n  &#40;= &#40;:role user&#41; :admin&#41;&#41;\n\n&#40;admin? user&#41;  ; =&gt; true\n</code></pre><p><strong>Benefits</strong>:</p><ul><li><strong>Serialization</strong>: Easy (it's already data—just write it)</li><li><strong>Testing</strong>: Easy (no mock objects—just pass data)</li><li><strong>Inspection</strong>: Easy (it's just maps and vectors—print them)<h2></h2></li></ul><h2>Concurrency: The Atom Model</h2><p><strong>Clojure's approach to mutable state</strong> (when you actually need it):</p><h3>Atoms (Synchronous, Independent)</h3><pre><code class=\"clojure\">;; Create mutable reference\n&#40;def counter &#40;atom 0&#41;&#41;\n\n;; Read it\n@counter  ; =&gt; 0\n\n;; Update it &#40;atomically&#41;\n&#40;swap! counter inc&#41;  ; =&gt; 1\n&#40;swap! counter inc&#41;  ; =&gt; 2\n\n;; Even with 10 threads calling inc simultaneously,\n;; you get correct count &#40;no race conditions!&#41;\n</code></pre><p><strong>How?</strong> <code>swap!</code> uses <strong>compare-and-swap</strong> (CAS) at hardware level. Retries if another thread changed the value. <strong>Lock-free concurrency.</strong></p><h3>Refs (Coordinated Transactions)</h3><pre><code class=\"clojure\">;; Transfer money between accounts &#40;must be atomic&#41;\n&#40;def alice-account &#40;ref 100&#41;&#41;\n&#40;def bob-account &#40;ref 50&#41;&#41;\n\n&#40;defn transfer &#91;from to amount&#93;\n  &#40;dosync\n    &#40;alter from - amount&#41;\n    &#40;alter to + amount&#41;&#41;&#41;\n\n&#40;transfer alice-account bob-account 20&#41;\n\n@alice-account  ; =&gt; 80\n@bob-account    ; =&gt; 70\n</code></pre><p><strong><code>dosync</code></strong> creates a <strong>transaction</strong>. Either both refs change, or neither does. <strong>STM (Software Transactional Memory)</strong>.</p><p><strong>No locks, no deadlocks, no race conditions.</strong> The runtime handles it.<h2></h2></p><h2>Clojure in Production</h2><p><strong>Who uses Clojure?</strong></p><ul><li><strong>Nubank</strong>: Brazil's largest fintech (1,000+ Clojure developers)</li><li><strong>Walmart</strong>: Product search, pricing engines</li><li><strong>Netflix</strong>: Some internal tools</li><li><strong>CircleCI</strong>: Continuous integration platform</li><li><strong>Funding Circle</strong>: Peer-to-peer lending</li><li><strong>Puppet Labs</strong>: Infrastructure automation</li></ul><p><strong>Why they chose Clojure</strong>:</p><ul><li><strong>Concurrency</strong> (handle thousands of requests without locks)</li><li><strong>Simplicity</strong> (easier to reason about, fewer bugs)</li><li><strong>JVM</strong> (mature platform, ops teams know it)</li><li><strong>REPL</strong> (debug production issues live!)</li><li><strong>Immutability</strong> (easier testing, reproducing bugs)</li></ul><p><strong>It's not just a hobby language.</strong> It's <strong>production-proven</strong> at scale.<h2></h2></p><h2>Hands-On: Your First Clojure</h2><h3>Exercise 1: Install Clojure</h3><p><strong>macOS/Linux</strong>:<pre><code class=\"bash\"># Install via brew &#40;macOS&#41;\nbrew install clojure/tools/clojure\n\n# Or via install script &#40;Linux&#41;\ncurl -L -O https://github.com/clojure/brew-install/releases/latest/download/linux-install.sh\nchmod +x linux-install.sh\nsudo ./linux-install.sh\n</code></pre></p><p><strong>Verify</strong>:<pre><code class=\"bash\">clj\n# Should start a REPL!\n</code></pre></p><h3>Exercise 2: REPL Exploration</h3><p><strong>In the REPL</strong>, try:</p><pre><code class=\"clojure\">;; Basic math\n&#40;+ 1 2 3 4 5&#41;\n\n;; Define a function\n&#40;defn square &#91;x&#93; &#40;&#42; x x&#41;&#41;\n&#40;square 7&#41;\n\n;; Higher-order function\n&#40;map square &#91;1 2 3 4 5&#93;&#41;\n\n;; Build a data structure\n&#40;def user {:name &quot;You&quot; :learning :clojure}&#41;\n\n;; Transform it\n&#40;assoc user :excited? true&#41;\n\n;; Quit\n&#40;System/exit 0&#41;\n</code></pre><p><strong>Notice</strong>: Instant feedback. No compile step. <strong>This is the Clojure way.</strong><h2></h2></p><h3>Exercise 3: Compare to a Language You Know</h3><p><strong>If you know JavaScript</strong>:<pre><code class=\"javascript\">// JS\nconst arr = &#91;1, 2, 3&#93;;\nconst doubled = arr.map&#40;x =&gt; x &#42; 2&#41;;\n</code></pre></p><pre><code class=\"clojure\">;; Clojure\n&#40;def arr &#91;1 2 3&#93;&#41;\n&#40;def doubled &#40;map #&#40;&#42; % 2&#41; arr&#41;&#41;\n</code></pre><p><strong>Similar!</strong> But Clojure:</p><ul><li>Is <strong>immutable</strong> by default (JS arrays are mutable)</li><li>Uses <strong>prefix</strong> notation <code>&#40;&#42; % 2&#41;</code> instead of <code>x &#42; 2</code></li><li>Returns <strong>lazy sequences</strong> (won't compute until needed)</li></ul><p><strong>If you know Python</strong>:<pre><code class=\"python\"># Python\nusers = &#91;{&quot;name&quot;: &quot;Alice&quot;}, {&quot;name&quot;: &quot;Bob&quot;}&#93;\nnames = &#91;u&#91;&quot;name&quot;&#93; for u in users&#93;\n</code></pre></p><pre><code class=\"clojure\">;; Clojure\n&#40;def users &#91;{:name &quot;Alice&quot;} {:name &quot;Bob&quot;}&#93;&#41;\n&#40;def names &#40;map :name users&#41;&#41;\n</code></pre><p><strong>Clojure is more concise</strong> (keywords are functions!) and <strong>immutable</strong> (Python lists are mutable).<h2></h2></p><h2>Try This</h2><h3>Exercise 1: Solve FizzBuzz</h3><p><strong>Classic interview question</strong>: Print 1-100, but:</p><ul><li>Multiples of 3: \"Fizz\"</li><li>Multiples of 5: \"Buzz\"</li><li>Multiples of both: \"FizzBuzz\"</li></ul><p><strong>Try in Clojure</strong>:<pre><code class=\"clojure\">&#40;defn fizzbuzz &#91;n&#93;\n  &#40;cond\n    &#40;zero? &#40;mod n 15&#41;&#41; &quot;FizzBuzz&quot;\n    &#40;zero? &#40;mod n 3&#41;&#41;  &quot;Fizz&quot;\n    &#40;zero? &#40;mod n 5&#41;&#41;  &quot;Buzz&quot;\n    :else              n&#41;&#41;\n\n&#40;map fizzbuzz &#40;range 1 101&#41;&#41;\n</code></pre></p><p><strong>Appreciate</strong>: How <strong>declarative</strong> this is (say what, not how).<h2></h2></p><h3>Exercise 2: Immutable Update</h3><p><strong>Task</strong>: Update a nested map.</p><pre><code class=\"clojure\">&#40;def system {:services {:web {:port 8080 :running true}\n                        :db  {:port 5432 :running true}}}&#41;\n\n;; Stop the web service &#40;deep update&#41;\n&#40;assoc-in system &#91;:services :web :running&#93; false&#41;\n\n;; Original unchanged!\nsystem  ; =&gt; {:services {:web {:port 8080 :running true} ...}}\n</code></pre><p><strong><code>assoc-in</code></strong> updates nested structures <strong>immutably</strong>. Try this in Python (you'll appreciate Clojure's elegance).<h2></h2></p><h3>Exercise 3: Build a Simple CLI</h3><pre><code class=\"clojure\">;; save as hello.clj\n&#40;ns hello.core&#41;\n\n&#40;defn -main &#91;&amp; args&#93;\n  &#40;println &quot;Hello,&quot; &#40;or &#40;first args&#41; &quot;Valley Builder&quot;&#41; &quot;!&quot;&#41;&#41;\n\n;; Run:\n;; clj -M -m hello.core Alice\n;; =&gt; &quot;Hello, Alice !&quot;\n</code></pre><p><strong>That's a complete CLI program.</strong> No boilerplate. Just functions and data.<h2></h2></p><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9520-functional-programming-basics'>9520: Functional Programming</a></strong> - Deep dive into FP concepts</li><li><strong><a href='/12025-10/9530-rich-hickey-simple-made-easy'>9530: Simplicity (Rich Hickey)</a></strong> - Full exploration of \"Simple Made Easy\"</li><li><strong><a href='/12025-10/9610-nix-package-manager'>9610: Nix Package Management</a></strong> - Another system prioritizing simplicity</li><li><strong>Phase 4</strong> - Full Clojure/ClojureScript deep dives (~essays 9801-9820)</li></ul><h3>External Resources</h3><ul><li><strong><a href='https://clojure.org'>clojure.org</a></strong> - Official site, excellent docs</li><li><strong>\"Clojure for the Brave and True\"</strong> - Free online book (fun, accessible)</li><li><strong>ClojureDocs</strong> - Community-driven examples</li><li><strong>Rich Hickey talks</strong> - \"Simple Made Easy\", \"The Value of Values\", \"Are We There Yet?\"</li><li><strong>4Clojure</strong> - Practice problems (learn by doing)</li></ul><h3>For the Narrative-Inclined</h3><ul><li><strong><a href='/12025-10/9949-intro-clojure-nix-ecosystem'>9949: The Wise Elders Meet</a></strong> - Clojure as character (the Functional Sage)<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Why does immutability prevent bugs?</strong> (If values can't change, whole classes of errors disappear)</li><li><strong>Is prefix notation really better?</strong> (Consistent vs special cases—what's the trade-off?)</li><li><strong>Could you REPL-drive your current work?</strong> (What would change if you had instant feedback?)</li><li><strong>What does \"simple\" mean to you?</strong> (Not easy, not familiar—but not intertwined)</li><li><strong>Is Clojure \"too weird\" or \"refreshingly different\"?</strong> (Depends on your openness to new paradigms)<h2></h2></li></ol><h2>Summary</h2><p><strong>Clojure is</strong>:</p><ul><li>A <strong>modern Lisp</strong> (2007) for the JVM and JavaScript</li><li><strong>Functional-first</strong> (immutability, pure functions, higher-order functions)</li><li><strong>Homoiconic</strong> (code is data—enables macros, metaprogramming)</li><li><strong>Practical</strong> (hosted on mature platforms, production-ready)</li><li><strong>REPL-driven</strong> (interactive development with instant feedback)</li><li><strong>Simple</strong> (prioritizes decomplecting over familiarity)</li></ul><p><strong>Key Insights</strong>:</p><ul><li><strong>Immutability</strong> = fearless concurrency + easier reasoning</li><li><strong>Code as data</strong> = powerful metaprogramming (macros!)</li><li><strong>Hosted approach</strong> = leverage existing ecosystems (JVM, JavaScript)</li><li><strong>REPL workflow</strong> = interactive development changes how you think</li><li><strong>Simple ≠ easy</strong> (unfamiliar can be simple, familiar can be complex)</li></ul><p><strong>Rich Hickey's Gift</strong>:</p><ul><li>Brought <strong>Lisp philosophy</strong> to mainstream platforms</li><li>Proved <strong>immutability</strong> is practical (not just academic)</li><li>Showed <strong>simplicity</strong> beats complexity (in the long run)</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>Clojure is a primary language</strong> (see our build scripts in <code>scripts/&#42;.clj</code>)</li><li>We use it for <strong>pipelines, parsing, validation, generation</strong></li><li>We'll use <strong>ClojureScript</strong> for browser interactivity (planned)</li><li>The <strong>Functional Sage</strong> (Essay 9949) represents Clojure's wisdom<h2></h2></li></ul><p><strong>Next</strong>: We'll explore the <strong>Unix Philosophy</strong>—principles that shaped computing for 50 years, and still guide us today. Clojure embodies many of these principles (\"do one thing well\" = simple functions!).<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9503-what-is-nock'>9503 (what is nock)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9505-house-of-wisdom-knowledge-gardens'>9505 (house of wisdom knowledge gardens)</a></p><p><strong>Bridge to Narrative</strong>: For the story of Clojure, see <a href='/12025-10/9949-intro-clojure-nix-ecosystem'>9949 (The Wise Elders)</a>!</p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 1</li><li><strong>Prerequisites</strong>: 9500, 9503</li><li><strong>Concepts</strong>: Lisp, functional programming, immutability, REPL, homoiconicity, macros, hosted languages</li><li><strong>Next Concepts</strong>: Unix philosophy, composition, pipes, do one thing well</li><li><strong>Code Examples</strong>: All runnable in Clojure REPL</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.428420904Z-25410"
}