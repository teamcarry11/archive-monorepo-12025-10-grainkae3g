{
  "slug" : "9520-functional-programming-basics",
  "meta" : {
    "slug" : "9520-functional-programming-basics",
    "title" : "kae3g 9520: Functional Programming - Computing with Pure Functions",
    "filename" : "9520-functional-programming-basics.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9520: Functional Programming - Computing with Pure Functions</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 2</strong> | <strong>Reading Time: 16 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>What functional programming (FP) actually means</li><li>Pure functions: same input → same output, no side effects</li><li>Immutability: why unchanging data prevents bugs</li><li>Higher-order functions: functions that take/return functions</li><li>Composition: building complex behavior from simple pieces</li><li>Why FP is becoming dominant (concurrency, testability, reasoning)</li><li>How FP relates to mathematics (lambda calculus, category theory)<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - Practical FP example</li><li><strong><a href='/12025-10/9510-unix-philosophy-do-one-thing-well'>9510: Unix Philosophy</a></strong> - Composition mindset<h2></h2></li></ul><h2>What Is Functional Programming?</h2><p><strong>The simple definition</strong>:</p><blockquote><p> <strong>Functional programming treats computation as the evaluation of mathematical functions and avoids changing state and mutable data.</strong> </p></blockquote><p><strong>Unpacking</strong>:</p><ul><li><strong>Computation = function evaluation</strong> (not sequences of instructions)</li><li><strong>Avoid changing state</strong> (no <code>x = x + 1</code>)</li><li><strong>Avoid mutable data</strong> (values don't change after creation)</li></ul><p><strong>The shift</strong>:</p><pre><code>Imperative: &quot;Do this, then do that, then do this other thing&quot;\n            &#40;recipe—list of steps&#41;\n\nFunctional: &quot;The answer is f&#40;g&#40;h&#40;input&#41;&#41;&#41;&quot;\n            &#40;equation—composition of functions&#41;\n</code></pre><h2></h2><h2>Pure Functions: The Foundation</h2><p><strong>A pure function</strong>:</p><ol><li><strong>Same input → same output</strong> (deterministic, no randomness)</li><li><strong>No side effects</strong> (doesn't change anything outside itself)</li></ol><h3>Examples</h3><p><strong>Pure</strong>:<pre><code class=\"clojure\">&#40;defn add &#91;x y&#93;\n  &#40;+ x y&#41;&#41;\n\n&#40;add 3 5&#41;  ; =&gt; 8\n&#40;add 3 5&#41;  ; =&gt; 8 &#40;always!&#41;\n</code></pre></p><ul><li>Same inputs (3, 5) → same output (8)</li><li>No side effects (doesn't print, doesn't write files, doesn't change global state)</li></ul><p><strong>Impure</strong> (side effect: printing):<pre><code class=\"clojure\">&#40;defn add-and-log &#91;x y&#93;\n  &#40;println &quot;Adding&quot; x &quot;and&quot; y&#41;  ; SIDE EFFECT!\n  &#40;+ x y&#41;&#41;\n\n&#40;add-and-log 3 5&#41;  \n; Prints: &quot;Adding 3 and 5&quot;\n; =&gt; 8\n</code></pre></p><ul><li>Still returns same output, but <strong>observable effect</strong> (printing)</li><li>Not mathematically pure</li></ul><p><strong>Impure</strong> (side effect: mutation):<pre><code class=\"javascript\">let total = 0;\n\nfunction addToTotal&#40;x&#41; {\n  total = total + x;  // SIDE EFFECT: mutates global\n  return total;\n}\n\naddToTotal&#40;5&#41;  ; =&gt; 5\naddToTotal&#40;5&#41;  ; =&gt; 10 &#40;different output for same input!&#41;\n</code></pre></p><ul><li><strong>Different outputs</strong> for same input</li><li><strong>Non-deterministic</strong> (output depends on when you call it)</li><li><strong>Hard to test</strong> (must set up global state)</li></ul><h3>Why Purity Matters</h3><p><strong>Benefits of pure functions</strong>:</p><ol><li><strong>Easy to test</strong><pre><code class=\"clojure\">;; Pure function: just call it\n&#40;add 3 5&#41;  ; =&gt; 8 &#40;test passed!&#41;\n\n;; Impure function: must set up state, mock I/O, etc.\n</code></pre></li><li><strong>Easy to reason about</strong><pre><code class=\"clojure\">;; What does this do?\n&#40;defn mystery &#91;x&#93; &#40;&#42; x x&#41;&#41;\n\n;; Just look at the code: squares its input\n;; No need to check global variables, database state, etc.\n</code></pre></li><li><strong>Parallel-safe</strong><pre><code class=\"clojure\">;; Call these in parallel—no race conditions!\n&#40;future &#40;add 1 2&#41;&#41;\n&#40;future &#40;add 3 4&#41;&#41;\n&#40;future &#40;add 5 6&#41;&#41;\n</code></pre></li><li><strong>Memoizable</strong> (cache results)<pre><code class=\"clojure\">;; Since &#40;expensive-calc 42&#41; always returns same value,\n;; compute once, cache forever\n&#40;def expensive-calc &#40;memoize expensive-calc&#41;&#41;\n</code></pre></li><li><strong>Time-travel debugging</strong><pre><code class=\"clojure\">;; Replay with same inputs → same outputs &#40;reproducible bugs!&#41;\n</code></pre><h2></h2></li></ol><h2>Immutability: Values That Never Change</h2><p><strong>Most languages</strong>: Variables <strong>vary</strong>.</p><pre><code class=\"python\">x = &#91;1, 2, 3&#93;\nx.append&#40;4&#41;  # Mutated!\n# x is now &#91;1, 2, 3, 4&#93;\n</code></pre><p><strong>FP languages</strong>: Values are <strong>immutable</strong>.</p><pre><code class=\"clojure\">&#40;def x &#91;1 2 3&#93;&#41;\n&#40;def y &#40;conj x 4&#41;&#41;  ; New value\n\nx  ; =&gt; &#91;1 2 3&#93; &#40;unchanged!&#41;\ny  ; =&gt; &#91;1 2 3 4&#93; &#40;new value&#41;\n</code></pre><h3>Why Immutability Prevents Bugs</h3><p><strong>The problem with mutation</strong>:</p><pre><code class=\"javascript\">function processUsers&#40;users&#41; {\n  users.sort&#40;&#40;a, b&#41; =&gt; a.age - b.age&#41;;  // MUTATES input!\n  return users.filter&#40;u =&gt; u.age &gt; 18&#41;;\n}\n\nconst allUsers = &#91;{name: &quot;Alice&quot;, age: 30}, {name: &quot;Bob&quot;, age: 17}&#93;;\nconst adults = processUsers&#40;allUsers&#41;;\n\n// allUsers is now SORTED &#40;side effect!&#41;\n// Other code expecting original order: BROKEN\n</code></pre><p><strong>With immutability</strong>:</p><pre><code class=\"clojure\">&#40;defn process-users &#91;users&#93;\n  &#40;-&gt;&gt; users\n       &#40;sort-by :age&#41;\n       &#40;filter #&#40;&gt; &#40;:age %&#41; 18&#41;&#41;&#41;&#41;\n\n&#40;def all-users &#91;{:name &quot;Alice&quot; :age 30} {:name &quot;Bob&quot; :age 17}&#93;&#41;\n&#40;def adults &#40;process-users all-users&#41;&#41;\n\n;; all-users is UNCHANGED &#40;no side effect&#41;\n;; Other code: SAFE\n</code></pre><p><strong>Immutability = no spooky action at a distance.</strong><h2></h2></p><h2>Higher-Order Functions</h2><p><strong>Functions that take functions as arguments</strong> or <strong>return functions as results</strong>.</p><h3>Map: Transform Each Element</h3><pre><code class=\"clojure\">&#40;map inc &#91;1 2 3 4 5&#93;&#41;\n; =&gt; &#40;2 3 4 5 6&#41;\n\n&#40;map square &#91;1 2 3 4 5&#93;&#41;\n; =&gt; &#40;1 4 9 16 25&#41;\n\n&#40;map :name &#91;{:name &quot;Alice&quot;} {:name &quot;Bob&quot;}&#93;&#41;\n; =&gt; &#40;&quot;Alice&quot; &quot;Bob&quot;&#41;\n</code></pre><p><strong><code>map</code> is a higher-order function</strong> (takes function <code>inc</code>, <code>square</code>, <code>:name</code> as argument).</p><h3>Filter: Keep Some Elements</h3><pre><code class=\"clojure\">&#40;filter even? &#91;1 2 3 4 5 6&#93;&#41;\n; =&gt; &#40;2 4 6&#41;\n\n&#40;filter #&#40;&gt; % 10&#41; &#91;5 15 3 20 7 30&#93;&#41;\n; =&gt; &#40;15 20 30&#41;\n</code></pre><p><strong><code>filter</code> is higher-order</strong> (takes predicate function as argument).</p><h3>Reduce: Combine Elements</h3><pre><code class=\"clojure\">&#40;reduce + &#91;1 2 3 4 5&#93;&#41;\n; =&gt; 15  &#40;1+2+3+4+5&#41;\n\n&#40;reduce &#42; &#91;1 2 3 4 5&#93;&#41;\n; =&gt; 120 &#40;1&#42;2&#42;3&#42;4&#42;5 = 5 factorial&#41;\n\n&#40;reduce &#40;fn &#91;acc x&#93; &#40;conj acc &#40;&#42; x x&#41;&#41;&#41; &#91;&#93; &#91;1 2 3 4 5&#93;&#41;\n; =&gt; &#91;1 4 9 16 25&#93;  &#40;build vector of squares&#41;\n</code></pre><p><strong><code>reduce</code> is the most powerful</strong> (can implement map, filter, and more using reduce!).</p><h3>Returning Functions (Closures)</h3><pre><code class=\"clojure\">&#40;defn make-multiplier &#91;factor&#93;\n  &#40;fn &#91;x&#93; &#40;&#42; x factor&#41;&#41;&#41;  ; Returns a function!\n\n&#40;def times-10 &#40;make-multiplier 10&#41;&#41;\n&#40;def times-100 &#40;make-multiplier 100&#41;&#41;\n\n&#40;times-10 5&#41;   ; =&gt; 50\n&#40;times-100 5&#41;  ; =&gt; 500\n</code></pre><p><strong>The returned function \"closes over\" <code>factor</code></strong> (remembers it). This is a <strong>closure</strong>.<h2></h2></p><h2>Composition: The Heart of FP</h2><p><strong>Mathematical composition</strong>:</p><pre><code>f&#40;x&#41; = x + 1\ng&#40;x&#41; = x &#42; 2\n\n&#40;g ∘ f&#41;&#40;x&#41; = g&#40;f&#40;x&#41;&#41; = &#40;x + 1&#41; &#42; 2\n</code></pre><p><strong>Functional programming</strong>:<pre><code class=\"clojure\">&#40;defn f &#91;x&#93; &#40;+ x 1&#41;&#41;\n&#40;defn g &#91;x&#93; &#40;&#42; x 2&#41;&#41;\n\n&#40;defn g-of-f &#91;x&#93;\n  &#40;g &#40;f x&#41;&#41;&#41;\n\n&#40;g-of-f 5&#41;  ; =&gt; 12  &#40;5+1=6, 6&#42;2=12&#41;\n</code></pre></p><p><strong>Using <code>comp</code></strong> (composition function):<pre><code class=\"clojure\">&#40;def g-of-f &#40;comp g f&#41;&#41;\n\n&#40;g-of-f 5&#41;  ; =&gt; 12\n</code></pre></p><p><strong>Or threading macros</strong>:<pre><code class=\"clojure\">&#40;-&gt; 5\n    f    ; 6\n    g&#41;   ; 12\n</code></pre></p><p><strong>Same idea as Unix pipes</strong>: Data flows through transformations.<h2></h2></p><h2>Declarative vs Imperative</h2><h3>Imperative (HOW to do it)</h3><pre><code class=\"javascript\">// Sum of squares of even numbers\nlet sum = 0;\nfor &#40;let i = 0; i &lt; arr.length; i++&#41; {\n  if &#40;arr&#91;i&#93; % 2 === 0&#41; {\n    sum += arr&#91;i&#93; &#42; arr&#91;i&#93;;\n  }\n}\n</code></pre><p><strong>Steps</strong>: Initialize sum, loop, check condition, update sum.</p><h3>Declarative (WHAT you want)</h3><pre><code class=\"clojure\">&#40;-&gt;&gt; arr\n     &#40;filter even?&#41;\n     &#40;map #&#40;&#42; % %&#41;&#41;\n     &#40;reduce +&#41;&#41;\n</code></pre><p><strong>Transformation pipeline</strong>: Filter evens → square each → sum.</p><p><strong>Benefits of declarative</strong>:</p><ul><li><strong>Reads like English</strong> (\"filter even, map square, reduce add\")</li><li><strong>No loop indices</strong> (no off-by-one errors!)</li><li><strong>No mutable accumulator</strong> (no <code>sum = sum + ...</code>)</li><li><strong>Easier to parallelize</strong> (map/filter can run in parallel—no shared state)<h2></h2></li></ul><h2>Why FP Is Winning</h2><h3>1. Concurrency</h3><p><strong>Mutable state + threads = race conditions</strong>:</p><pre><code class=\"python\"># Two threads incrementing counter\ncounter = 0\n\ndef increment&#40;&#41;:\n    global counter\n    counter = counter + 1  # NOT ATOMIC!\n\n# Thread 1: read 0, add 1, write 1\n# Thread 2: read 0, add 1, write 1  &#40;race!&#41;\n# Result: 1 &#40;should be 2&#41;\n</code></pre><p><strong>Fix</strong>: Locks (complex, slow, deadlock-prone).</p><p><strong>FP approach</strong>: <strong>Immutable data</strong></p><pre><code class=\"clojure\">;; No mutation → no race conditions\n&#40;defn increment &#91;counter&#93;\n  &#40;+ counter 1&#41;&#41;\n\n;; Call from any thread—safe!\n</code></pre><p><strong>For actual shared state</strong>: Clojure's atoms (compare-and-swap, lock-free).</p><h3>2. Testability</h3><p><strong>Pure functions are trivial to test</strong>:</p><pre><code class=\"clojure\">&#40;defn add &#91;x y&#93; &#40;+ x y&#41;&#41;\n\n;; Test:\n&#40;assert &#40;= &#40;add 2 3&#41; 5&#41;&#41;\n&#40;assert &#40;= &#40;add 0 0&#41; 0&#41;&#41;\n&#40;assert &#40;= &#40;add -1 1&#41; 0&#41;&#41;\n\n;; No setup, no mocking, no teardown\n</code></pre><p><strong>Impure functions</strong>:</p><pre><code class=\"javascript\">function saveUser&#40;user&#41; {\n  database.insert&#40;user&#41;;  // Side effect!\n  sendEmail&#40;user.email&#41;;  // Side effect!\n  logAudit&#40;user.id&#41;;      // Side effect!\n}\n\n// Test: Mock database, email service, logger...\n// Complex, fragile, slow\n</code></pre><h3>3. Reasoning</h3><p><strong>Pure functions are equations</strong>:</p><pre><code class=\"clojure\">&#40;defn total &#91;prices&#93;\n  &#40;reduce + prices&#41;&#41;\n\n;; You can reason algebraically:\n&#40;total &#91;&#93;&#41; = 0  &#40;identity&#41;\n&#40;total &#91;a&#93;&#41; = a\n&#40;total &#91;a b&#93;&#41; = a + b &#40;associative, commutative&#41;\n</code></pre><p><strong>Impure functions</strong>: Must trace through execution, track state, consider order.<h2></h2></p><h2>FP Concepts in Other Languages</h2><p><strong>FP isn't Clojure-only.</strong> It's spreading:</p><h3>JavaScript (Functional Style)</h3><pre><code class=\"javascript\">// Imperative\nlet doubled = &#91;&#93;;\nfor &#40;let i = 0; i &lt; arr.length; i++&#41; {\n  doubled.push&#40;arr&#91;i&#93; &#42; 2&#41;;\n}\n\n// Functional\nconst doubled = arr.map&#40;x =&gt; x &#42; 2&#41;;\n</code></pre><p><strong>ES6+ embraced FP</strong>: <code>map</code>, <code>filter</code>, <code>reduce</code>, arrow functions, const/let.</p><h3>Python (Functional Tools)</h3><pre><code class=\"python\"># map, filter, reduce\nfrom functools import reduce\n\nnums = &#91;1, 2, 3, 4, 5&#93;\ndoubled = list&#40;map&#40;lambda x: x &#42; 2, nums&#41;&#41;\nevens = list&#40;filter&#40;lambda x: x % 2 == 0, nums&#41;&#41;\ntotal = reduce&#40;lambda acc, x: acc + x, nums&#41;\n</code></pre><p><strong>Or comprehensions</strong> (functional in spirit):<pre><code class=\"python\">doubled = &#91;x &#42; 2 for x in nums&#93;\nevens = &#91;x for x in nums if x % 2 == 0&#93;\n</code></pre></p><h3>Rust (FP + Safety)</h3><pre><code class=\"rust\">let nums = vec!&#91;1, 2, 3, 4, 5&#93;;\n\nlet doubled: Vec&lt;&#95;&gt; = nums.iter&#40;&#41;\n    .map&#40;|x| x &#42; 2&#41;\n    .collect&#40;&#41;;\n\nlet total: i32 = nums.iter&#40;&#41;.sum&#40;&#41;;\n</code></pre><p><strong>Rust combines FP (immutability, composition) with systems programming (no GC, memory safety).</strong><h2></h2></p><h2>Hands-On: FP Practice</h2><h3>Exercise 1: Refactor to Pure</h3><p><strong>Given</strong> (impure):<pre><code class=\"javascript\">let total = 0;\n\nfunction addToTotal&#40;x&#41; {\n  total += x;\n  return total;\n}\n</code></pre></p><p><strong>Refactor</strong> (pure):<pre><code class=\"javascript\">function add&#40;total, x&#41; {\n  return total + x;\n}\n\n// Call site manages state\nlet total = 0;\ntotal = add&#40;total, 5&#41;;\ntotal = add&#40;total, 3&#41;;\n</code></pre></p><p><strong>Or with reduce</strong>:<pre><code class=\"javascript\">const total = &#91;5, 3, 7&#93;.reduce&#40;add, 0&#41;;\n</code></pre></p><h2></h2><h3>Exercise 2: Composition</h3><p><strong>Build a pipeline</strong>:</p><pre><code class=\"clojure\">;; Given: list of numbers\n;; Want: sum of squares of even numbers\n\n;; Step 1: Filter evens\n&#40;filter even? &#91;1 2 3 4 5 6&#93;&#41;  ; =&gt; &#40;2 4 6&#41;\n\n;; Step 2: Square each\n&#40;map #&#40;&#42; % %&#41; &#91;2 4 6&#93;&#41;  ; =&gt; &#40;4 16 36&#41;\n\n;; Step 3: Sum\n&#40;reduce + &#91;4 16 36&#93;&#41;  ; =&gt; 56\n\n;; Compose:\n&#40;-&gt;&gt; &#91;1 2 3 4 5 6&#93;\n     &#40;filter even?&#41;\n     &#40;map #&#40;&#42; % %&#41;&#41;\n     &#40;reduce +&#41;&#41;  ; =&gt; 56\n</code></pre><p><strong>Try</strong>: Sum of cubes of odd numbers in [1..10].<h2></h2></p><h3>Exercise 3: Higher-Order Function</h3><p><strong>Write your own <code>map</code></strong>:</p><pre><code class=\"clojure\">&#40;defn my-map &#91;f coll&#93;\n  &#40;if &#40;empty? coll&#41;\n    '&#40;&#41;\n    &#40;cons &#40;f &#40;first coll&#41;&#41;\n          &#40;my-map f &#40;rest coll&#41;&#41;&#41;&#41;&#41;\n\n&#40;my-map inc &#91;1 2 3&#93;&#41;  ; =&gt; &#40;2 3 4&#41;\n&#40;my-map square &#91;1 2 3&#93;&#41;  ; =&gt; &#40;1 4 9&#41;\n</code></pre><p><strong>Recursive definition</strong>:</p><ul><li>Empty list → empty result</li><li>Non-empty → apply <code>f</code> to first, recurse on rest</li></ul><p><strong>This is how <code>map</code> is actually defined</strong> (conceptually—optimized in practice).<h2></h2></p><h2>Common FP Patterns</h2><h3>1. Map-Reduce</h3><p><strong>Pattern</strong>: Transform each item (<code>map</code>), then combine (<code>reduce</code>).</p><pre><code class=\"clojure\">;; Total price of items\n&#40;def items &#91;{:name &quot;Widget&quot; :price 10}\n            {:name &quot;Gadget&quot; :price 20}\n            {:name &quot;Gizmo&quot; :price 15}&#93;&#41;\n\n&#40;-&gt;&gt; items\n     &#40;map :price&#41;   ; Extract prices: &#40;10 20 15&#41;\n     &#40;reduce +&#41;&#41;    ; Sum: 45\n</code></pre><p><strong>Scales to distributed computing</strong> (MapReduce, Hadoop, Spark—same pattern!).</p><h3>2. Pipeline (Threading)</h3><p><strong>Pattern</strong>: Data flows through transformations.</p><pre><code class=\"clojure\">&#40;-&gt; data\n    parse       ; data → parsed\n    validate    ; parsed → validated\n    transform   ; validated → transformed\n    save&#41;       ; transformed → saved\n</code></pre><p><strong>Each step returns new data.</strong> No mutation.</p><p><strong>Like Unix pipes</strong>, but for data structures.</p><h3>3. Currying (Partial Application)</h3><p><strong>Currying</strong>: Convert <code>f&#40;x, y&#41;</code> to <code>f&#40;x&#41;&#40;y&#41;</code>.</p><pre><code class=\"clojure\">;; Normal function\n&#40;defn add &#91;x y&#93; &#40;+ x y&#41;&#41;\n&#40;add 10 5&#41;  ; =&gt; 15\n\n;; Partial application &#40;fix first argument&#41;\n&#40;def add10 &#40;partial add 10&#41;&#41;\n&#40;add10 5&#41;  ; =&gt; 15\n&#40;add10 20&#41; ; =&gt; 30\n</code></pre><p><strong>Useful for creating specialized functions</strong> from general ones:</p><pre><code class=\"clojure\">&#40;def log-error &#40;partial log :error&#41;&#41;\n&#40;def log-info &#40;partial log :info&#41;&#41;\n\n&#40;log-error &quot;Something broke&quot;&#41;  ; Same as: &#40;log :error &quot;Something broke&quot;&#41;\n</code></pre><h2></h2><h2>FP and Mathematics</h2><h3>Lambda Calculus (Alonzo Church, 1930s)</h3><p><strong>The mathematical foundation of FP</strong>:</p><pre><code>λx. x + 1        ; Function taking x, returning x+1\n&#40;λx. x + 1&#41; 5    ; Apply to 5 → 6\n</code></pre><p><strong>All computable functions</strong> can be expressed in lambda calculus (Church-Turing thesis).</p><p><strong>Modern FP languages</strong> are lambda calculus + practical features (types, I/O, performance).</p><h3>Category Theory</h3><p><strong>Composition in category theory</strong>:</p><pre><code>Objects: Types &#40;Integer, String, User&#41;\nMorphisms: Functions &#40;Integer → String&#41;\nComposition: f: A → B, g: B → C ⇒ g ∘ f: A → C\n</code></pre><p><strong>Laws</strong>:</p><ul><li><strong>Associativity</strong>: <code>&#40;h ∘ g&#41; ∘ f = h ∘ &#40;g ∘ f&#41;</code></li><li><strong>Identity</strong>: <code>id ∘ f = f ∘ id = f</code></li></ul><p><strong>FP respects these laws</strong>:</p><pre><code class=\"clojure\">;; Associativity\n&#40;comp h &#40;comp g f&#41;&#41; ≡ &#40;comp &#40;comp h g&#41; f&#41; ≡ &#40;comp h g f&#41;\n\n;; Identity\n&#40;comp identity f&#41; ≡ &#40;comp f identity&#41; ≡ f\n</code></pre><p><strong>We'll explore this deeply in Essay 9730: Category Theory for Programmers.</strong><h2></h2></p><h2>FP vs OOP</h2><p><strong>The eternal debate</strong>: Functional vs Object-Oriented Programming.</p><h3>OOP Approach</h3><pre><code class=\"java\">class User {\n  private String name;\n  private int age;\n  \n  public User&#40;String name, int age&#41; {\n    this.name = name;\n    this.age = age;\n  }\n  \n  public void haveBirthday&#40;&#41; {\n    this.age += 1;  // Mutation!\n  }\n  \n  public boolean isAdult&#40;&#41; {\n    return this.age &gt;= 18;\n  }\n}\n\nUser alice = new User&#40;&quot;Alice&quot;, 17&#41;;\nalice.haveBirthday&#40;&#41;;  // Mutated!\n</code></pre><p><strong>OOP bundles</strong>:</p><ul><li><strong>Data</strong> (fields)</li><li><strong>Behavior</strong> (methods)</li><li><strong>Identity</strong> (this object vs that object)</li></ul><h3>FP Approach</h3><pre><code class=\"clojure\">;; Just data\n&#40;def alice {:name &quot;Alice&quot; :age 17}&#41;\n\n;; Functions on data\n&#40;defn have-birthday &#91;user&#93;\n  &#40;update user :age inc&#41;&#41;\n\n&#40;defn adult? &#91;user&#93;\n  &#40;&gt;= &#40;:age user&#41; 18&#41;&#41;\n\n;; Use:\n&#40;def older-alice &#40;have-birthday alice&#41;&#41;\n&#40;adult? older-alice&#41;  ; =&gt; true\n\n;; Original unchanged:\nalice  ; =&gt; {:name &quot;Alice&quot;, :age 17}\n</code></pre><p><strong>FP separates</strong>:</p><ul><li><strong>Data</strong> (maps, vectors)</li><li><strong>Behavior</strong> (functions)</li><li><strong>Identity</strong> (managed explicitly if needed)</li></ul><h3>Which Is Better?</h3><p><strong>It depends.</strong></p><p><strong>OOP strengths</strong>:</p><ul><li><strong>Encapsulation</strong> (hide implementation details)</li><li><strong>Polymorphism</strong> (different objects, same interface)</li><li><strong>Familiar</strong> (most programmers learned OOP first)</li></ul><p><strong>FP strengths</strong>:</p><ul><li><strong>Testability</strong> (pure functions)</li><li><strong>Concurrency</strong> (immutability)</li><li><strong>Composition</strong> (small functions → complex behavior)</li><li><strong>Reasoning</strong> (equations, not stateful objects)</li></ul><p><strong>Modern synthesis</strong>: Use <strong>both</strong>!</p><ul><li>OOP for <strong>structure</strong> (modules, namespaces, encapsulation)</li><li>FP for <strong>logic</strong> (pure functions, immutability, composition)</li></ul><p><strong>Clojure's approach</strong>: FP by default, OOP when needed (protocols, records).<h2></h2></p><h2>Try This</h2><h3>Exercise 1: Refactor to Immutable</h3><p><strong>Imperative</strong> (mutation):<pre><code class=\"javascript\">function updateUsers&#40;users&#41; {\n  for &#40;let user of users&#41; {\n    user.lastSeen = Date.now&#40;&#41;;\n  }\n  return users;\n}\n</code></pre></p><p><strong>Functional</strong> (immutable):<pre><code class=\"clojure\">&#40;defn update-users &#91;users&#93;\n  &#40;map #&#40;assoc % :last-seen &#40;now&#41;&#41; users&#41;&#41;\n</code></pre></p><p><strong>Benefits</strong>:</p><ul><li>Original <code>users</code> unchanged (no side effect)</li><li>Easier to test (just call with sample data)</li><li>Parallel-safe (no mutation)<h2></h2></li></ul><h3>Exercise 2: Build with Higher-Order Functions</h3><p><strong>Problem</strong>: Given list of numbers, return list of those that are perfect squares.</p><p><strong>Imperative</strong>:<pre><code class=\"python\">result = &#91;&#93;\nfor n in nums:\n    if int&#40;n &#42;&#42; 0.5&#41; &#42;&#42; 2 == n:\n        result.append&#40;n&#41;\n</code></pre></p><p><strong>Functional</strong>:<pre><code class=\"clojure\">&#40;defn perfect-square? &#91;n&#93;\n  &#40;let &#91;root &#40;Math/sqrt n&#41;&#93;\n    &#40;= n &#40;&#42; root root&#41;&#41;&#41;&#41;\n\n&#40;filter perfect-square? nums&#41;\n</code></pre></p><p><strong>One line!</strong> (Plus the helper function.)<h2></h2></p><h3>Exercise 3: Compose Complex Behavior</h3><p><strong>Problem</strong>: Process a list of users:</p><ol><li>Filter active users</li><li>Extract names</li><li>Sort alphabetically</li><li>Take first 10</li><li>Join with commas</li></ol><p><strong>Functional composition</strong>:<pre><code class=\"clojure\">&#40;-&gt;&gt; users\n     &#40;filter :active?&#41;\n     &#40;map :name&#41;\n     &#40;sort&#41;\n     &#40;take 10&#41;\n     &#40;clojure.string/join &quot;, &quot;&#41;&#41;\n</code></pre></p><p><strong>Five transformations, one pipeline.</strong> Clear, testable, composable.<h2></h2></p><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - FP in practice</li><li><strong><a href='/12025-10/9530-rich-hickey-simple-made-easy'>9530: Simplicity</a></strong> - Why FP aligns with simplicity</li><li><strong><a href='/12025-10/9540-types-sets-mathematical-foundations'>9540: Types and Sets</a></strong> - Mathematical foundations</li><li><strong><a href='/12025-10/9730-category-theory-for-programmers'>9730: Category Theory</a></strong> - Mathematical structure of FP</li></ul><h3>External Resources</h3><ul><li><strong>\"Structure and Interpretation of Computer Programs\"</strong> (SICP) - Classic FP text</li><li><strong>Rich Hickey</strong>, \"The Value of Values\" talk - Why immutability matters</li><li><strong>\"Functional Programming in JavaScript\"</strong> by Luis Atencio</li><li><strong>\"Learn You a Haskell\"</strong> - Pure FP language (more extreme than Clojure)</li></ul><h3>For the Mathematically Curious</h3><ul><li><strong>Lambda calculus</strong> - Church's original formulation</li><li><strong>Curry-Howard correspondence</strong> - Programs are proofs!</li><li><strong>Haskell</strong> - The purest FP language (forces purity via type system)<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Can all programs be pure?</strong> (No—I/O is inherently impure. But you can isolate impurity.)</li><li><strong>Is immutability too expensive?</strong> (Persistent data structures make it O(log n), not O(n))</li><li><strong>Why isn't FP more popular?</strong> (Unfamiliar, steeper learning curve—but gaining adoption)</li><li><strong>When should you use mutation?</strong> (Performance hotspots, interfacing with mutable APIs—but minimize)</li><li><strong>Is OOP dead?</strong> (No—but FP ideas are infiltrating OOP languages)<h2></h2></li></ol><h2>Summary</h2><p><strong>Functional Programming</strong>:</p><ul><li><strong>Treats computation as function evaluation</strong> (not sequential instructions)</li><li><strong>Pure functions</strong> (same input → same output, no side effects)</li><li><strong>Immutable data</strong> (values never change)</li><li><strong>Higher-order functions</strong> (functions as arguments/results)</li><li><strong>Composition</strong> (build complex from simple)</li></ul><p><strong>Key Insights</strong>:</p><ul><li><strong>Purity enables testability</strong> (just call the function!)</li><li><strong>Immutability enables concurrency</strong> (no locks needed)</li><li><strong>Composition enables reuse</strong> (small functions → unlimited combinations)</li><li><strong>Declarative style</strong> (say what, not how) is clearer</li></ul><p><strong>Benefits</strong>:</p><ul><li><strong>Fewer bugs</strong> (no mutation, no hidden state)</li><li><strong>Easier testing</strong> (pure functions, no setup)</li><li><strong>Better concurrency</strong> (immutable data, no races)</li><li><strong>Mathematical reasoning</strong> (functions are equations)</li></ul><p><strong>Trade-offs</strong>:</p><ul><li><strong>Unfamiliar</strong> (learning curve for imperative programmers)</li><li><strong>Performance</strong> (sometimes mutation is faster—but optimize later)</li><li><strong>Purity limits</strong> (some problems need effects—IO, randomness, time)</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>FP is the default</strong> (Clojure, Nix expressions, Haskell-inspired thinking)</li><li><strong>Immutability is sacred</strong> (treat data as immutable until proven necessary to mutate)</li><li><strong>Composition is key</strong> (small functions, Unix-style pipelines)</li><li><strong>Simple over clever</strong> (clear code > terse code)<h2></h2></li></ul><p><strong>Next</strong>: We'll explore <strong>Rich Hickey's \"Simple Made Easy\"</strong> in depth—the philosophy underlying both Clojure and the valley itself.<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9516-complete-stack-in-action'>9516 (complete stack in action)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9530-rich-hickey-simple-made-easy'>9530 (rich hickey simple made easy)</a></p><p><strong>Bridge to Narrative</strong>: For FP storytelling, see <a href='/12025-10/9949-intro-clojure-nix-ecosystem'>9949 (The Wise Elders)</a> - Clojure as the Functional Sage!</p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 2</li><li><strong>Prerequisites</strong>: 9504, 9510</li><li><strong>Concepts</strong>: Pure functions, immutability, higher-order functions, map/filter/reduce, composition, declarative vs imperative</li><li><strong>Next Concepts</strong>: Simplicity philosophy, decomplecting, Rich Hickey's design principles</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.429049098Z-20374"
}