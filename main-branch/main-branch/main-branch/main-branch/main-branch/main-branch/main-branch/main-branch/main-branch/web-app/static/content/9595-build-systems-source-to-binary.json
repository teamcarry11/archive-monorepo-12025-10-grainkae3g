{
  "slug" : "9595-build-systems-source-to-binary",
  "meta" : {
    "slug" : "9595-build-systems-source-to-binary",
    "title" : "kae3g 9594: Build Systems - From Source to Binary",
    "filename" : "9595-build-systems-source-to-binary.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9594: Build Systems - From Source to Binary</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 4</strong> | <strong>Reading Time: 16 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>How source code becomes executable programs</li><li>Compilation vs interpretation</li><li>The build pipeline (preprocess, compile, assemble, link)</li><li>Build tools (make, ninja, Bazel, Nix)</li><li>Why reproducible builds matter</li><li>Incremental builds (rebuild only what changed)</li><li>Nix as the ultimate build system</li><li>Build systems as recipe management (plant lens)<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9560-text-files-universal-format'>9560: Text Files</a></strong> - Source code is text</li><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - Compilation in dynamic languages</li><li><strong><a href='/12025-10/9590-filesystem-hierarchical-organization'>9590: Filesystem</a></strong> - Where build artifacts live<h2></h2></li></ul><h2>From Seeds to Harvest</h2><p><strong>Source code</strong> (text files): Dormant potential, like seeds</p><p><strong>Build process</strong>: Transformation into executable, like growing plants</p><p><strong>Binary executable</strong>: Running program, like harvested crop</p><p><strong>Plant lens</strong>: <strong>\"Build systems are recipes for growing crops from seeds—taking source (seeds) and producing binaries (harvest).\"</strong><h2></h2></p><h2>Compilation vs Interpretation</h2><h3>Compiled Languages</h3><p><strong>C, Rust, Go</strong>:</p><pre><code>Source code &#40;.c, .rs, .go&#41;\n    ↓ compile\nMachine code &#40;binary&#41;\n    ↓ run\nExecutable program\n</code></pre><p><strong>Pros</strong>:</p><ul><li><strong>Fast</strong> (already machine code)</li><li><strong>Distributed</strong> (ship binary, not source)</li></ul><p><strong>Cons</strong>:</p><ul><li><strong>Compilation time</strong> (must rebuild to test)</li><li><strong>Platform-specific</strong> (x86 binary won't run on ARM)</li></ul><h3>Interpreted Languages</h3><p><strong>Python, JavaScript, Ruby</strong>:</p><pre><code>Source code &#40;.py, .js, .rb&#41;\n    ↓ run\nInterpreter &#40;reads source, executes&#41;\n</code></pre><p><strong>Pros</strong>:</p><ul><li><strong>Quick iteration</strong> (edit → run immediately)</li><li><strong>Portable</strong> (same source runs on any platform with interpreter)</li></ul><p><strong>Cons</strong>:</p><ul><li><strong>Slower</strong> (interpreting overhead)</li><li><strong>Requires interpreter</strong> (can't ship just binary)</li></ul><h3>Hybrid (JVM, Clojure)</h3><pre><code>Source code &#40;.clj, .java&#41;\n    ↓ compile\nBytecode &#40;.class&#41;\n    ↓ run\nJVM &#40;interprets/JITs bytecode&#41;\n</code></pre><p><strong>Best of both</strong>: Fast-ish (JIT compilation), portable (bytecode works anywhere).<h2></h2></p><h2>The Compilation Pipeline</h2><p><strong>For C program</strong>:</p><h3>Step 1: Preprocessing</h3><pre><code class=\"c\">// hello.c\n#include &lt;stdio.h&gt;\n#define MESSAGE &quot;Hello, Valley!&quot;\n\nint main&#40;&#41; {\n    printf&#40;&quot;%s\\n&quot;, MESSAGE&#41;;\n}\n</code></pre><p><strong>Preprocessor</strong> expands macros, includes headers:<pre><code class=\"bash\">gcc -E hello.c -o hello.i\n\n# hello.i now has entire stdio.h contents + &quot;Hello, Valley!&quot; inline\n</code></pre></p><h3>Step 2: Compilation</h3><p><strong>C → Assembly</strong>:<pre><code class=\"bash\">gcc -S hello.i -o hello.s\n\n# hello.s contains assembly code:\n#   mov edi, OFFSET FLAT:.LC0\n#   call puts\n#   ...\n</code></pre></p><h3>Step 3: Assembly</h3><p><strong>Assembly → Machine code</strong>:<pre><code class=\"bash\">as hello.s -o hello.o\n\n# hello.o is binary &#40;object file&#41;\n# Contains machine instructions, but not yet executable\n</code></pre></p><h3>Step 4: Linking</h3><p><strong>Combine object files + libraries</strong>:<pre><code class=\"bash\">ld hello.o /usr/lib/libc.so -o hello\n\n# hello is now executable!\n</code></pre></p><p><strong>Or all at once</strong>:<pre><code class=\"bash\">gcc hello.c -o hello\n# &#40;gcc runs all 4 steps internally&#41;\n</code></pre></p><h2></h2><h2>Build Tools: Automating the Process</h2><h3>Make (1976, Stuart Feldman)</h3><p><strong>Makefile</strong>:<pre><code class=\"makefile\"># Target: dependencies\n#     command\n\nhello: hello.o\n\tgcc hello.o -o hello\n\nhello.o: hello.c\n\tgcc -c hello.c -o hello.o\n\nclean:\n\trm -f hello hello.o\n</code></pre></p><p><strong>Run</strong>:<pre><code class=\"bash\">make hello\n# Output:\n# gcc -c hello.c -o hello.o\n# gcc hello.o -o hello\n\nmake clean\n# rm -f hello hello.o\n</code></pre></p><p><strong>Benefit</strong>: <strong>Incremental</strong> (only rebuilds what changed).</p><p><strong>Problem</strong>: <strong>Imperative</strong> (you specify HOW to build, not just WHAT).</p><h3>Ninja (2012, Evan Martin)</h3><p><strong>Faster than Make</strong>:</p><ul><li>Simpler syntax (generated by tools, not hand-written)</li><li>Parallel by default (uses all CPU cores)</li><li>Used by: Chromium, LLVM, Meson</li></ul><p><strong>Not hand-written</strong> (too low-level). Tools generate <code>build.ninja</code> files.</p><h3>Bazel (Google)</h3><p><strong>Scalable</strong> (handles huge codebases):</p><ul><li><strong>Hermetic builds</strong> (isolated, reproducible)</li><li><strong>Distributed</strong> (can farm out to build servers)</li><li><strong>Incremental</strong> (caches aggressively)</li></ul><p><strong>Used by</strong>: Google (entire codebase), large projects.</p><p><strong>Problem</strong>: Complex (learning curve, overhead for small projects).</p><h3>Nix (The Ultimate!)</h3><p><strong>Declarative, reproducible, isolated</strong>:</p><pre><code class=\"nix\"># default.nix\n{ pkgs ? import &lt;nixpkgs&gt; {} }:\n\npkgs.stdenv.mkDerivation {\n  name = &quot;hello&quot;;\n  src = ./.;\n  buildInputs = &#91; pkgs.gcc &#93;;\n  \n  buildPhase = ''\n    gcc hello.c -o hello\n  '';\n  \n  installPhase = ''\n    mkdir -p $out/bin\n    cp hello $out/bin/\n  '';\n}\n</code></pre><p><strong>Build</strong>:<pre><code class=\"bash\">nix-build\n# Result: ./result/bin/hello\n</code></pre></p><p><strong>Benefits</strong>:</p><ul><li><strong>Reproducible</strong> (same inputs → same output, always)</li><li><strong>Isolated</strong> (dependencies don't conflict)</li><li><strong>Cacheable</strong> (binary cache - never rebuild same thing)</li><li><strong>Rollbackable</strong> (old versions stay around)</li></ul><p><strong>This is sovereignty</strong> (Essay 9503, 9960 - grainhouse strategy!).<h2></h2></p><h2>Why Reproducible Builds Matter</h2><p><strong>Problem</strong>: \"Works on my machine!\"</p><pre><code>Developer:   Builds fine ✅\nCI server:   Build fails ❌\nProduction:  Different binary ⚠️\n</code></pre><p><strong>Causes</strong>:</p><ul><li>Different dependency versions</li><li>Different OS</li><li>Different timestamps (embedded in binary)</li><li>Non-deterministic build steps</li></ul><p><strong>Solution</strong>: <strong>Reproducible builds</strong> (same source + same environment → bit-identical binary).</p><p><strong>Nix guarantees this</strong> (hermetic builds, locked dependencies).</p><p><strong>Why it matters</strong>:</p><ul><li><strong>Security</strong>: Can verify binary matches source (no backdoor injection)</li><li><strong>Debugging</strong>: If production binary differs, you can't reproduce bugs</li><li><strong>Trust</strong>: Users can build from source, verify it matches distributed binary</li></ul><p><strong>Plant lens</strong>: <strong>\"Reproducible builds are like saving seeds—plant the same seed in same soil → get identical plant.\"</strong><h2></h2></p><h2>Incremental Builds</h2><p><strong>Problem</strong>: Rebuilding <strong>everything</strong> wastes time.</p><p><strong>Solution</strong>: Track dependencies, rebuild <strong>only what changed</strong>.</p><p><strong>Example</strong> (make):<pre><code class=\"makefile\">main: main.o utils.o\n\tgcc main.o utils.o -o main\n\nmain.o: main.c utils.h\n\tgcc -c main.c\n\nutils.o: utils.c utils.h\n\tgcc -c utils.c\n</code></pre></p><p><strong>Change <code>main.c</code></strong>:<pre><code class=\"bash\">make\n# Only recompiles main.c → main.o\n# Then relinks main\n# Skips utils.c &#40;unchanged!&#41;\n</code></pre></p><p><strong>Nix approach</strong>: Hash-based (content-addressed):</p><ul><li>Each dependency has a hash</li><li>If hash unchanged, use cached result</li><li>No manual dependency tracking needed!<h2></h2></li></ul><h2>The Nix Build Model</h2><p><strong>Nix is special</strong> (Essay 9504 mentioned it):</p><h3>Hermetic Builds</h3><p><strong>Isolated</strong> from system:</p><pre><code>Traditional build:\n  gcc hello.c -o hello\n  # Uses: system gcc, system libc, system headers\n  # &#40;Depends on what's installed!&#41;\n\nNix build:\n  Uses: /nix/store/abc123-gcc-11.2/bin/gcc\n        /nix/store/def456-glibc-2.35/\n  # Everything explicit, isolated\n  # &#40;Doesn't depend on system state!&#41;\n</code></pre><p><strong>Result</strong>: Same Nix expression → same binary (always).</p><h3>Content-Addressed</h3><p><strong>Derivations</strong> are hashed:</p><pre><code>/nix/store/abc123-hello-1.0\n           └─────┘\n           Hash of: source + dependencies + build script\n</code></pre><p><strong>If ANY input changes</strong> (source, dependencies, script), hash changes → rebuild.</p><p><strong>If nothing changed</strong>, use cached result → instant!</p><p><strong>This is perfect</strong> for grainhouse strategy (Essay 9960).<h2></h2></p><h2>Try This</h2><h3>Exercise 1: Manual Compilation</h3><pre><code class=\"bash\"># Write simple C program\ncat &gt; hello.c &lt;&lt;EOF\n#include &lt;stdio.h&gt;\nint main&#40;&#41; {\n    printf&#40;&quot;Hello, Valley!\\n&quot;&#41;;\n    return 0;\n}\nEOF\n\n# Compile step-by-step\ngcc -E hello.c -o hello.i     # Preprocess\ngcc -S hello.i -o hello.s     # Compile to assembly\nas hello.s -o hello.o          # Assemble to object file\ngcc hello.o -o hello           # Link to executable\n\n# Run\n./hello\n</code></pre><p><strong>Observe</strong>: Four distinct steps (usually hidden by <code>gcc hello.c -o hello</code>).<h2></h2></p><h3>Exercise 2: Make Incremental Build</h3><pre><code class=\"bash\"># Create Makefile\ncat &gt; Makefile &lt;&lt;EOF\nhello: hello.o\n\tgcc hello.o -o hello\n\nhello.o: hello.c\n\tgcc -c hello.c -o hello.o\n\nclean:\n\trm -f hello hello.o\nEOF\n\n# First build\nmake hello\n\n# No changes, rebuild:\nmake hello\n# Output: make: 'hello' is up to date.\n\n# Change source:\necho &quot;// comment&quot; &gt;&gt; hello.c\n\n# Rebuild &#40;incremental!&#41;\nmake hello\n# Only recompiles hello.c\n</code></pre><p><strong>Observe</strong>: Make tracks timestamps, rebuilds only what's needed.<h2></h2></p><h3>Exercise 3: Nix Build (if you have Nix)</h3><pre><code class=\"bash\"># Create simple Nix expression\ncat &gt; default.nix &lt;&lt;EOF\n{ pkgs ? import &lt;nixpkgs&gt; {} }:\n\npkgs.writeScriptBin &quot;hello&quot; ''\n  echo &quot;Hello from Nix!&quot;\n''\nEOF\n\n# Build\nnix-build\n\n# Run\n./result/bin/hello\n</code></pre><p><strong>Observe</strong>: Nix handles dependencies, isolation, caching automatically.<h2></h2></p><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - JVM compilation</li><li><strong><a href='/12025-10/9560-text-files-universal-format'>9560: Text Files</a></strong> - Source as text</li><li><strong><a href='/12025-10/9595-package-managers-dependency-resolution'>9595: Package Managers</a></strong> - Dependency management</li><li><strong><a href='/12025-10/9960-grainhouse-risc-v-synthesis'>9960: The Grainhouse</a></strong> - Nix for sovereignty</li></ul><h3>External Resources</h3><ul><li><strong><code>man gcc</code></strong> - Compiler documentation</li><li><strong>\"The Nix Manual\"</strong> - Complete Nix reference</li><li><strong>Bazel documentation</strong> - Google's build system</li><li><strong>\"Recursive Make Considered Harmful\"</strong> - Classic paper on Make's flaws<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Why do build systems exist?</strong> (Can't we just <code>gcc &#42;.c</code>? What breaks at scale?)</li><li><strong>Is reproducibility always achievable?</strong> (Timestamps, randomness, network - how to handle?)</li><li><strong>Should all builds be hermetic?</strong> (Nix says yes - but what's the cost? Disk space, complexity)</li><li><strong>What if source code directly executed?</strong> (Interpreted languages do this - trade-offs?)</li><li><strong>How would Nock build systems work?</strong> (Pure functions (noun → noun) - deterministic by definition!)<h2></h2></li></ol><h2>Summary</h2><p><strong>Build Systems Transform</strong>:</p><ul><li><strong>Source code</strong> (text) → <strong>Executables</strong> (machine code)</li></ul><p><strong>Compilation Pipeline</strong>:</p><ol><li><strong>Preprocess</strong>: Expand macros, include headers</li><li><strong>Compile</strong>: C → Assembly</li><li><strong>Assemble</strong>: Assembly → Object code</li><li><strong>Link</strong>: Object files → Executable</li></ol><p><strong>Build Tools</strong>:</p><ul><li><strong>Make</strong> (1976): Incremental, imperative, timestamp-based</li><li><strong>Ninja</strong> (2012): Fast, parallel, generated</li><li><strong>Bazel</strong> (Google): Scalable, hermetic, distributed</li><li><strong>Nix</strong> (Ultimate): Declarative, reproducible, content-addressed</li></ul><p><strong>Key Concepts</strong>:</p><ul><li><strong>Incremental builds</strong>: Rebuild only what changed</li><li><strong>Reproducible builds</strong>: Same inputs → same output (always)</li><li><strong>Hermetic builds</strong>: Isolated (no system dependencies)</li><li><strong>Content-addressed</strong>: Hash-based caching</li></ul><p><strong>Why Reproducibility</strong>:</p><ul><li><strong>Security</strong>: Verify binary matches source</li><li><strong>Debugging</strong>: Reproduce exact production binary</li><li><strong>Trust</strong>: Users can build and verify</li></ul><p><strong>Nix Advantages</strong>:</p><ul><li>Truly reproducible (hermetic, locked deps)</li><li>Content-addressed (perfect caching)</li><li>Declarative (what, not how)</li><li>Sovereignty (grainhouse strategy!)</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>We prefer Nix</strong> (reproducibility, sovereignty)</li><li><strong>We value incremental</strong> (fast iteration)</li><li><strong>We verify builds</strong> (reproducible → security)</li><li><strong>We understand the pipeline</strong> (not just black box)</li></ul><p><strong>Plant lens</strong>: <strong>\"Build systems are recipes—transform seeds (source) into crops (binaries) through systematic cultivation (compilation pipeline).\"</strong><h2></h2></p><p><strong>Next</strong>: We'll explore <strong>package managers</strong>—how to manage dependencies at scale, the problem Nix solves beautifully, and why dependency hell exists!<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9594-concurrency-threads-parallelism'>9594 (concurrency threads parallelism)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9596-package-managers-dependency-resolution'>9596 (package managers dependency resolution)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 4</li><li><strong>Prerequisites</strong>: 9560, 9504, 9590</li><li><strong>Concepts</strong>: Compilation, linking, build systems, Make, Nix, reproducible builds, incremental builds</li><li><strong>Next Concepts</strong>: Package managers, dependency resolution, Nix deep dive</li><li><strong>Plant Lens</strong>: Seeds (source) → crops (binaries), recipes (build systems), cultivation (compilation)</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.42947859Z-12505"
}