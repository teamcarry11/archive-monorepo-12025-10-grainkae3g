{
  "slug" : "9580-memory-management",
  "meta" : {
    "slug" : "9580-memory-management",
    "title" : "kae3g 9580: Memory Management - Stack, Heap, and Virtual Memory",
    "filename" : "9580-memory-management.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9580: Memory Management - Stack, Heap, and Virtual Memory</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 3</strong> | <strong>Reading Time: 17 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>How processes use memory (stack vs heap)</li><li>Virtual memory: The beautiful illusion your OS creates</li><li>Memory allocation and deallocation</li><li>Memory leaks and how to avoid them</li><li>Why garbage collection matters (or doesn't)</li><li>Memory as a finite resource (like water in a garden)</li><li>Practical debugging with memory tools<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9500-what-is-a-computer'>9500: What Is a Computer?</a></strong> - Memory basics</li><li><strong><a href='/12025-10/9570-processes-programs-in-motion'>9570: Processes</a></strong> - How processes work</li><li><strong><a href='/12025-10/9507-helen-atthowe-ecological-systems'>9507: Helen Atthowe</a></strong> - Resource management metaphor<h2></h2></li></ul><h2>Memory: The Finite Garden</h2><p><strong>Plant lens</strong>: Memory is like <strong>water in your garden</strong>.</p><ul><li><strong>Limited resource</strong> (4GB, 16GB, 64GB RAM - but still finite!)</li><li><strong>Processes compete</strong> (like plants for water)</li><li><strong>Waste depletes it</strong> (memory leaks = water runoff)</li><li><strong>Must be managed carefully</strong> (drip irrigation > flood and hope)</li></ul><p><strong>This essay</strong>: How your OS and programs manage this precious resource.<h2></h2></p><h2>The Memory Hierarchy</h2><p><strong>Your computer has multiple \"layers\" of memory</strong> (speed vs capacity trade-off):</p><table><thead><tr><th>Type</th><th>Size</th><th>Speed</th><th>Purpose</th></tr></thead><tbody><tr><td><strong>CPU Registers</strong></td><td>~100 bytes</td><td>Fastest (1 cycle)</td><td>Current operation</td></tr><tr><td><strong>L1 Cache</strong></td><td>~32 KB</td><td>Very fast (2-4 cycles)</td><td>Hot data</td></tr><tr><td><strong>L2 Cache</strong></td><td>~256 KB</td><td>Fast (10-20 cycles)</td><td>Warm data</td></tr><tr><td><strong>L3 Cache</strong></td><td>~8 MB</td><td>Moderate (40-60 cycles)</td><td>Shared cache</td></tr><tr><td><strong>RAM (Main Memory)</strong></td><td>4-64 GB</td><td>Slow (100+ cycles)</td><td>Active data</td></tr><tr><td><strong>SSD</strong></td><td>256 GB - 2 TB</td><td>Very slow (100,000+ cycles)</td><td>Persistent data</td></tr><tr><td><strong>HDD</strong></td><td>1-8 TB</td><td>Extremely slow (1,000,000+ cycles)</td><td>Cold storage</td></tr></tbody></table><p><strong>Key insight</strong>: CPU is <strong>starving</strong> for data (registers empty in nanoseconds). Memory hierarchy tries to keep it fed.</p><p><strong>This essay focuses on RAM</strong> (main memory) - where your processes live.<h2></h2></p><h2>Virtual Memory: The Beautiful Illusion</h2><p><strong>Physical memory</strong> (RAM): 16 GB (example).</p><p><strong>Your process thinks</strong>: \"I have the entire 64-bit address space!\" (18 exabytes = 18 billion GB!)</p><p><strong>How?</strong> <strong>Virtual memory</strong> - OS creates an illusion.</p><h3>The Mapping</h3><p><strong>Each process has</strong>:</p><ul><li><strong>Virtual address space</strong> (huge, e.g., 0x0000 to 0x7FFF<i>FFFF</i>FFFF)</li><li><strong>Page table</strong> (maps virtual addresses → physical addresses)</li></ul><p><strong>Example</strong>:</p><pre><code>Virtual Address    Physical Address\n0x1000&#95;0000   →    0x0A3F&#95;2000  &#40;in RAM&#41;\n0x1000&#95;1000   →    0x0B12&#95;8000  &#40;in RAM&#41;\n0x2000&#95;0000   →    &#40;not mapped - will page fault!&#41;\n0x3000&#95;0000   →    &#40;on disk, swap file&#41;\n</code></pre><p><strong>Benefits</strong>:</p><ol><li><strong>Isolation</strong>: Process can't access another's memory (security!)</li><li><strong>Simplicity</strong>: Program sees contiguous memory (even if fragmented in RAM)</li><li><strong>Overcommit</strong>: Total virtual memory > physical RAM (use disk as backup)</li></ol><p><strong>Plant lens</strong>: Like <strong>terraced gardens</strong> (each level thinks it has flat land, but it's transformed by the landscape).<h2></h2></p><h2>Stack vs Heap</h2><p><strong>Your process memory</strong> is divided into regions:</p><pre><code>High addresses &#40;0x7FFF&#95;FFFF&#95;FFFF&#41;\n    ↑\n    | Stack &#40;grows downward&#41;\n    |   - Local variables\n    |   - Function call frames\n    |   - Return addresses\n    |\n    | &#40;unused space&#41;\n    |\n    | Heap &#40;grows upward&#41;\n    ↓   - Dynamically allocated memory\n    |   - malloc&#40;&#41;, new, etc.\n    |\n    | BSS &#40;uninitialized data&#41;\n    | Data &#40;initialized global variables&#41;\n    | Text &#40;code&#41;\nLow addresses &#40;0x0000&#95;0000&#41;\n</code></pre><h3>The Stack</h3><p><strong>Automatic memory management</strong>:</p><pre><code class=\"c\">void function&#40;&#41; {\n    int x = 10;        // On stack\n    char buffer&#91;100&#93;;  // On stack\n    \n    // When function returns, x and buffer are GONE\n    // &#40;stack frame is popped&#41;\n}\n</code></pre><p><strong>Properties</strong>:</p><ul><li><strong>Fast</strong> (just adjust stack pointer)</li><li><strong>Limited size</strong> (typically 1-8 MB per thread)</li><li><strong>LIFO</strong> (Last In, First Out - like a stack of plates)</li><li><strong>Automatic cleanup</strong> (no memory leaks!)</li></ul><p><strong>Stack overflow</strong>: If you exceed stack size (e.g., infinite recursion):<pre><code class=\"c\">void infinite&#40;&#41; {\n    int bigArray&#91;1000000&#93;;  // 4 MB!\n    infinite&#40;&#41;;  // Recurse → stack overflow\n}\n</code></pre></p><p><strong>Plant lens</strong>: Stack is like <strong>annual plants</strong> (live one season, then gone automatically).</p><h3>The Heap</h3><p><strong>Manual memory management</strong>:</p><pre><code class=\"c\">void function&#40;&#41; {\n    int&#42; x = malloc&#40;sizeof&#40;int&#41;&#41;;  // On heap\n    &#42;x = 10;\n    \n    // x still exists after function returns!\n    // Must call free&#40;x&#41; or it leaks!\n}\n</code></pre><p><strong>Properties</strong>:</p><ul><li><strong>Slower</strong> (complex allocation algorithms)</li><li><strong>Large</strong> (gigabytes available)</li><li><strong>Random access</strong> (allocate/free in any order)</li><li><strong>Manual cleanup</strong> (or garbage collector)</li></ul><p><strong>Memory leak</strong>: Forgetting to free:<pre><code class=\"c\">void leak&#40;&#41; {\n    int&#42; x = malloc&#40;100&#41;;\n    // ... use x ...\n    // Forgot to free&#40;x&#41;!\n    // That 100 bytes is LOST until process exits\n}\n</code></pre></p><p><strong>Plant lens</strong>: Heap is like <strong>perennial plants</strong> (live for years, must be tended or they overgrow).<h2></h2></p><h2>Memory Allocation: Under the Hood</h2><p><strong>When you call <code>malloc&#40;100&#41;</code></strong>:</p><ol><li><strong>Heap allocator</strong> searches for free block (≥100 bytes)</li><li><strong>Splits block</strong> if larger than needed (e.g., 256 byte block → 100 used + 156 free)</li><li><strong>Updates metadata</strong> (linked list of free blocks)</li><li><strong>Returns pointer</strong> to your memory</li></ol><p><strong>When you call <code>free&#40;ptr&#41;</code></strong>:</p><ol><li><strong>Mark block as free</strong></li><li><strong>Coalesce</strong> with adjacent free blocks (merge to reduce fragmentation)</li><li><strong>Update free list</strong></li></ol><p><strong>Fragmentation problem</strong>:</p><pre><code>Heap: &#91;used 50&#93;&#91;free 10&#93;&#91;used 30&#93;&#91;free 10&#93;&#91;used 20&#93;\nYou need: 20 bytes\n\nProblem: Two 10-byte free blocks, but not contiguous!\nCan't allocate 20 bytes &#40;even though 20 bytes free total&#41;.\n\nThis is FRAGMENTATION.\n</code></pre><p><strong>Solution</strong>: Garbage collector (compacts memory) or careful allocation patterns.<h2></h2></p><h2>Garbage Collection vs Manual Management</h2><h3>Manual (C, C++, Rust without GC)</h3><p><strong>You control</strong>:<pre><code class=\"c\">int&#42; x = malloc&#40;100&#41;;\n// ... use x ...\nfree&#40;x&#41;;  // YOU must free!\n</code></pre></p><p><strong>Pros</strong>:</p><ul><li><strong>Predictable</strong> (you know when free happens)</li><li><strong>Low overhead</strong> (no GC pauses)</li><li><strong>Fine control</strong> (can optimize for cache, etc.)</li></ul><p><strong>Cons</strong>:</p><ul><li><strong>Error-prone</strong> (forget to free → leak, double free → crash)</li><li><strong>Complex</strong> (ownership rules, lifetimes)</li></ul><p><strong>Rust</strong>: Compile-time memory safety (borrow checker prevents leaks/dangling pointers).</p><h3>Garbage Collection (Java, Python, JavaScript, Go, Clojure)</h3><p><strong>System controls</strong>:<pre><code class=\"java\">Object x = new Object&#40;&#41;;  // Allocated\n// ... use x ...\n// No explicit free!\n// GC reclaims it when no references remain\n</code></pre></p><p><strong>Pros</strong>:</p><ul><li><strong>Safe</strong> (no manual free → no double-free, no leaks from forgetting)</li><li><strong>Simple</strong> (don't think about memory)</li></ul><p><strong>Cons</strong>:</p><ul><li><strong>Unpredictable pauses</strong> (GC runs when it wants)</li><li><strong>Overhead</strong> (GC tracking uses CPU/memory)</li><li><strong>Less control</strong> (can't fine-tune for performance)</li></ul><p><strong>Trade-off</strong>: Safety vs control.</p><p><strong>Plant lens</strong>: </p><ul><li><strong>Manual = hand-watering</strong> each plant (precise, but labor-intensive)</li><li><strong>GC = automated irrigation</strong> (convenient, but less precise)<h2></h2></li></ul><h2>Memory Leaks: The Silent Killer</h2><p><strong>A memory leak</strong>: Memory allocated but never freed.</p><p><strong>Example</strong> (JavaScript):<pre><code class=\"javascript\">let cache = {};\n\nfunction addToCache&#40;key, value&#41; {\n    cache&#91;key&#93; = value;\n    // Never remove old entries!\n    // Cache grows forever → memory leak!\n}\n\n// Fix: Periodically prune cache\nfunction pruneCache&#40;&#41; {\n    const maxSize = 1000;\n    if &#40;Object.keys&#40;cache&#41;.length &gt; maxSize&#41; {\n        cache = {};  // Reset\n    }\n}\n</code></pre></p><p><strong>Symptoms</strong>:</p><ul><li>Process memory grows over time</li><li>Eventually: Out of memory (OOM), crash</li><li>Slow performance (more GC pressure)</li></ul><p><strong>Debugging</strong>:<pre><code class=\"bash\"># Watch memory usage\ntop -pid &lt;PID&gt;\n\n# Or:\nhtop  # Visual\n\n# Heap profiler &#40;Node.js&#41;\nnode --inspect app.js\n# Use Chrome DevTools → Memory tab\n</code></pre></p><p><strong>Plant lens</strong>: Memory leak = <strong>invasive species</strong> (grows unchecked, chokes out other plants).<h2></h2></p><h2>Virtual Memory in Practice</h2><h3>Page Faults</h3><p><strong>What happens</strong> when you access unmapped memory?</p><pre><code class=\"c\">int&#42; ptr = &#40;int&#42;&#41;0x10000000;  // Virtual address\n&#42;ptr = 42;  // Write to this address\n</code></pre><p><strong>Steps</strong>:</p><ol><li><strong>CPU tries to access</strong> 0x10000000</li><li><strong>MMU (Memory Management Unit)</strong> checks page table</li><li><strong>Not mapped!</strong> → <strong>Page fault</strong> (trap to kernel)</li><li><strong>Kernel decides</strong>:<ul><li>Valid but not in RAM? → Load from disk (swap in)</li><li>Invalid address? → <strong>Segmentation fault</strong> (kill process!)</li></ul></li><li><strong>Resume</strong> (if valid)</li></ol><p><strong>Types of page faults</strong>:</p><ul><li><strong>Minor</strong>: Page in memory, just needs mapping (fast)</li><li><strong>Major</strong>: Page on disk, must load (slow!)</li><li><strong>Invalid</strong>: Illegal access (crash!)</li></ul><h3>Swapping</h3><p><strong>Physical RAM full?</strong> OS moves pages to disk (swap space).</p><pre><code>Process A:  &#91;Page 1&#93; &#91;Page 2&#93; &#91;Page 3&#93; &#91;Page 4&#93;\n           In RAM    In RAM   On disk  In RAM\n\n# Process accesses Page 3 &#40;on disk&#41;\n# OS swaps out Page 4 &#40;least recently used&#41;\n# OS swaps in Page 3\n\nProcess A:  &#91;Page 1&#93; &#91;Page 2&#93; &#91;Page 3&#93; &#91;Page 4&#93;\n           In RAM    In RAM   In RAM   On disk\n</code></pre><p><strong>Thrashing</strong>: Too much swapping (disk is slow!), system grinds to halt.</p><p><strong>Plant lens</strong>: Swapping = <strong>compost bin</strong> (temporarily store what doesn't fit in active garden, retrieve when needed).<h2></h2></p><h2>Memory Safety: Rust vs C</h2><h3>C (Unsafe)</h3><p><strong>Dangling pointer</strong>:<pre><code class=\"c\">int&#42; ptr = malloc&#40;sizeof&#40;int&#41;&#41;;\n&#42;ptr = 42;\nfree&#40;ptr&#41;;\n&#42;ptr = 10;  // DANGLING POINTER! &#40;ptr points to freed memory&#41;\n            // Undefined behavior &#40;might crash, might corrupt data&#41;\n</code></pre></p><p><strong>Buffer overflow</strong>:<pre><code class=\"c\">char buffer&#91;10&#93;;\nstrcpy&#40;buffer, &quot;This is way too long!&quot;&#41;;  // OVERFLOW!\n// Writes past buffer end, corrupts adjacent memory\n// Security vulnerability!\n</code></pre></p><h3>Rust (Safe)</h3><p><strong>Ownership rules</strong> (compile-time):<pre><code class=\"rust\">fn main&#40;&#41; {\n    let x = Box::new&#40;42&#41;;  // Heap allocation\n    let y = x;  // Ownership moves to y\n    \n    // println!&#40;&quot;{}&quot;, x&#41;;  // COMPILE ERROR! &#40;x no longer owns the data&#41;\n    println!&#40;&quot;{}&quot;, y&#41;;  // OK\n}  // y dropped, memory freed automatically\n</code></pre></p><p><strong>Borrow checker</strong>:<pre><code class=\"rust\">fn main&#40;&#41; {\n    let mut x = vec!&#91;1, 2, 3&#93;;\n    let y = &amp;x;  // Immutable borrow\n    \n    // x.push&#40;4&#41;;  // COMPILE ERROR! &#40;can't mutate while borrowed&#41;\n    println!&#40;&quot;{:?}&quot;, y&#41;;\n}  // y's borrow ends, x can be mutated again\n</code></pre></p><p><strong>Result</strong>: Memory safety <strong>without</strong> garbage collection (compile-time guarantees!).</p><p><strong>Plant lens</strong>: Rust is <strong>no-till farming</strong> (Helen Atthowe, Essay 9507) - gentle, precise intervention, no disruption.<h2></h2></p><h2>Practical Memory Debugging</h2><h3>Tools</h3><p><strong>C/C++</strong>:<pre><code class=\"bash\"># Valgrind &#40;memory leak detector&#41;\nvalgrind --leak-check=full ./myprogram\n\n# Output:\n# LEAK SUMMARY:\n#    definitely lost: 100 bytes in 1 blocks\n#    &#40;Shows where allocation happened&#41;\n</code></pre></p><p><strong>Rust</strong>:<pre><code class=\"bash\"># Miri &#40;interpreter that detects undefined behavior&#41;\ncargo +nightly miri run\n\n# Or just compile &#40;borrow checker catches most issues&#41;\ncargo build\n</code></pre></p><p><strong>Java</strong>:<pre><code class=\"bash\"># Heap dump\njmap -dump:live,format=b,file=heap.bin &lt;pid&gt;\n\n# Analyze with VisualVM, Eclipse MAT, etc.\n</code></pre></p><p><strong>JavaScript (Node.js)</strong>:<pre><code class=\"bash\"># Heap snapshot\nnode --inspect app.js\n# Chrome DevTools → Memory → Take snapshot\n</code></pre></p><h3>Detecting Leaks</h3><p><strong>Pattern</strong>:</p><ol><li><strong>Baseline</strong>: Measure memory at start</li><li><strong>Exercise</strong>: Run workload</li><li><strong>Idle</strong>: Let GC run, stabilize</li><li><strong>Compare</strong>: Memory higher than baseline? Leak!</li></ol><p><strong>Example</strong> (Node.js):<pre><code class=\"javascript\">console.log&#40;process.memoryUsage&#40;&#41;.heapUsed&#41;;\n// 10 MB\n\nfor &#40;let i = 0; i &lt; 1000; i++&#41; {\n    doWork&#40;&#41;;\n}\n\nglobal.gc&#40;&#41;;  // Force GC &#40;node --expose-gc&#41;\nconsole.log&#40;process.memoryUsage&#40;&#41;.heapUsed&#41;;\n// 50 MB &#40;grew 40 MB - leak!&#41;\n</code></pre></p><h2></h2><h2>Memory-Efficient Design</h2><h3>Principle 1: Reuse Allocations</h3><p><strong>Bad</strong> (allocate every time):<pre><code class=\"clojure\">&#40;defn process-items &#91;items&#93;\n  &#40;map &#40;fn &#91;item&#93;\n         &#40;let &#91;buffer &#40;byte-array 1024&#41;&#93;  ; Allocate!\n           &#40;process item buffer&#41;&#41;&#41;\n       items&#41;&#41;\n;; Allocates 1024 bytes × N items &#40;wasteful!&#41;\n</code></pre></p><p><strong>Good</strong> (reuse buffer):<pre><code class=\"clojure\">&#40;defn process-items &#91;items&#93;\n  &#40;let &#91;buffer &#40;byte-array 1024&#41;&#93;  ; Allocate once\n    &#40;map &#40;fn &#91;item&#93;\n           &#40;process item buffer&#41;&#41;  ; Reuse\n         items&#41;&#41;&#41;\n;; Allocates 1024 bytes once &#40;efficient!&#41;\n</code></pre></p><h3>Principle 2: Lazy Evaluation</h3><p><strong>Bad</strong> (realize entire sequence):<pre><code class=\"clojure\">&#40;def huge-data &#40;range 1000000&#41;&#41;  ; 1M integers in memory!\n\n&#40;defn process-all &#91;&#93;\n  &#40;doall &#40;map expensive-operation huge-data&#41;&#41;&#41;\n;; All 1M results in memory at once!\n</code></pre></p><p><strong>Good</strong> (lazy, process incrementally):<pre><code class=\"clojure\">&#40;def huge-data &#40;range 1000000&#41;&#41;\n\n&#40;defn process-all &#91;&#93;\n  &#40;doseq &#91;item huge-data&#93;  ; Lazy, one at a time\n    &#40;expensive-operation item&#41;&#41;&#41;\n;; Only one item in memory at a time!\n</code></pre></p><h3>Principle 3: Avoid Defensive Copies</h3><p><strong>Bad</strong> (copy unnecessarily):<pre><code class=\"clojure\">&#40;defn get-config &#91;&#93;\n  &#40;let &#91;config &#40;load-config&#41;&#93;\n    &#40;into {} config&#41;&#41;&#41;  ; COPY &#40;defensive, but wasteful if config is immutable!&#41;\n</code></pre></p><p><strong>Good</strong> (immutable, no copy needed):<pre><code class=\"clojure\">&#40;defn get-config &#91;&#93;\n  &#40;load-config&#41;&#41;  ; Return directly &#40;immutable, safe to share!&#41;\n</code></pre></p><p><strong>Clojure wins</strong>: Persistent data structures (structural sharing) avoid copies.<h2></h2></p><h2>Try This</h2><h3>Exercise 1: Measure Your Process Memory</h3><pre><code class=\"bash\"># Start a process\npython3 -c &quot;import time; x = &#91;0&#93; &#42; 10000000; time.sleep&#40;60&#41;&quot;\n# &#40;Allocates &#126;80 MB, sleeps 60 seconds&#41;\n\n# In another terminal:\nps aux | grep python3\n# Look at RSS &#40;Resident Set Size&#41; column\n\n# Or:\ntop -pid &lt;PID&gt;\n</code></pre><p><strong>Observe</strong>: Memory usage (RSS) shows ~80 MB.<h2></h2></p><h3>Exercise 2: Create a Memory Leak</h3><pre><code class=\"python\"># leak.py\ncache = &#91;&#93;\n\nwhile True:\n    cache.append&#40;&quot;x&quot; &#42; 1000000&#41;  # 1 MB string\n    print&#40;f&quot;Allocated {len&#40;cache&#41;} MB&quot;&#41;\n    import time\n    time.sleep&#40;1&#41;\n\n# Run:\npython3 leak.py\n\n# Watch memory grow &#40;top or htop&#41;\n# Ctrl-C to stop before OOM!\n</code></pre><p><strong>Observe</strong>: Memory grows indefinitely (leak!).<h2></h2></p><h3>Exercise 3: Profile Heap Allocation</h3><p><strong>Rust</strong>:<pre><code class=\"bash\">cargo install cargo-flamegraph\ncargo flamegraph --bin myapp\n\n# Opens flamegraph &#40;visual heap profile&#41;\n</code></pre></p><p><strong>Node.js</strong>:<pre><code class=\"bash\">node --inspect app.js\n# Chrome → chrome://inspect → Open DevTools\n# Memory tab → Take heap snapshot\n</code></pre></p><h2></h2><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9500-what-is-a-computer'>9500: What Is a Computer?</a></strong> - Memory hierarchy basics</li><li><strong><a href='/12025-10/9570-processes-programs-in-motion'>9570: Processes</a></strong> - How processes use memory</li><li><strong><a href='/12025-10/9507-helen-atthowe-ecological-systems'>9507: Helen Atthowe</a></strong> - Resource management (water = memory)</li><li><strong><a href='/12025-10/9955-redox-os-rust-microkernel'>9955: Redox OS</a></strong> - Rust memory safety (narrative series)</li></ul><h3>External Resources</h3><ul><li><strong>\"What Every Programmer Should Know About Memory\"</strong> - Ulrich Drepper (deep dive)</li><li><strong>Valgrind documentation</strong> - Memory debugging tools</li><li><strong>Rust Book Chapter 4</strong> - Ownership and borrowing</li><li><strong>\"The Garbage Collection Handbook\"</strong> - Comprehensive GC reference<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Is garbage collection \"free\"?</strong> (What are you trading? Convenience for...?)</li><li><strong>Can you have memory leaks in a GC'd language?</strong> (Yes! Holding references = memory can't be collected)</li><li><strong>Why does Rust's borrow checker prevent memory issues?</strong> (Compile-time tracking of ownership = no runtime errors)</li><li><strong>Is virtual memory always good?</strong> (Hides real limits, can lead to thrashing if overused)</li><li><strong>How much memory does your main project use?</strong> (Have you measured? Profiled? Optimized?)<h2></h2></li></ol><h2>Summary</h2><p><strong>Memory Management Concepts</strong>:</p><p><strong>Virtual Memory</strong>:</p><ul><li>Each process sees huge address space (illusion!)</li><li>Page tables map virtual → physical addresses</li><li>Isolation (processes can't access each other's memory)</li></ul><p><strong>Stack vs Heap</strong>:</p><ul><li><strong>Stack</strong>: Fast, automatic, limited (LIFO, function locals)</li><li><strong>Heap</strong>: Slower, manual/GC, large (random access, long-lived data)</li></ul><p><strong>Allocation Strategies</strong>:</p><ul><li><strong>Manual</strong> (C/C++): Full control, error-prone</li><li><strong>GC</strong> (Java/Python/Clojure): Safe, overhead</li><li><strong>Rust</strong>: Compile-time safety, no GC!</li></ul><p><strong>Memory Issues</strong>:</p><ul><li><strong>Leaks</strong>: Allocate but never free (grows until OOM)</li><li><strong>Dangling pointers</strong>: Use-after-free (undefined behavior)</li><li><strong>Fragmentation</strong>: Free space exists but not contiguous</li></ul><p><strong>Key Insights</strong>:</p><ul><li><strong>Memory is finite</strong> (like water in a garden - manage carefully!)</li><li><strong>Virtual memory is illusion</strong> (brilliant OS abstraction)</li><li><strong>Stack is fast, heap is flexible</strong> (use each appropriately)</li><li><strong>GC trades control for safety</strong> (no one-size-fits-all)</li><li><strong>Rust proves GC optional</strong> (compile-time guarantees work!)</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>We respect memory limits</strong> (finite resource, like water)</li><li><strong>We profile before optimizing</strong> (observation before action - Helen's principle)</li><li><strong>We choose immutability</strong> (Clojure persistent data - structural sharing)</li><li><strong>We avoid premature allocation</strong> (lazy evaluation, reuse buffers)</li></ul><p><strong>Plant lens</strong>: <strong>\"Memory is water—finite, must flow to all plants (processes), leaks waste it, closed-loop systems conserve it.\"</strong><h2></h2></p><p><strong>Next</strong>: We'll explore <strong>the filesystem</strong>—how your OS organizes persistent storage hierarchically, like a well-structured garden with paths, directories, and careful organization!<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9570-processes-programs-in-motion'>9570 (processes programs in motion)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9591-filesystem-hierarchical-organization'>9591 (filesystem hierarchical organization)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 3</li><li><strong>Prerequisites</strong>: 9500, 9570, 9507</li><li><strong>Concepts</strong>: Virtual memory, stack, heap, garbage collection, memory leaks, Rust ownership, page faults, swapping</li><li><strong>Next Concepts</strong>: Filesystem, directories, paths, inodes</li><li><strong>Plant Lens</strong>: Memory = water (finite resource), leaks = runoff, closed-loop = conservation, stack = annuals, heap = perennials</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.42929193Z-18105"
}