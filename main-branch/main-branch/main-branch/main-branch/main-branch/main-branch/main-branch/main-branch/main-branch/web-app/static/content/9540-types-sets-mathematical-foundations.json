{
  "slug" : "9540-types-sets-mathematical-foundations",
  "meta" : {
    "slug" : "9540-types-sets-mathematical-foundations",
    "title" : "kae3g 9540: Types and Sets - Mathematical Foundations of Programming",
    "filename" : "9540-types-sets-mathematical-foundations.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9540: Types and Sets - Mathematical Foundations of Programming</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 3</strong> | <strong>Reading Time: 15 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>What types are (mathematically and practically)</li><li>How types relate to sets in mathematics</li><li>Type systems: what they prevent and what they enable</li><li>Static vs dynamic typing (trade-offs, not dogma)</li><li>Algebraic data types: products and sums</li><li>How types guide design and catch errors</li><li>Why \"types are theorems\" (Curry-Howard correspondence)<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9500-what-is-a-computer'>9500: What Is a Computer?</a></strong> - Computational foundations</li><li><strong><a href='/12025-10/9520-functional-programming-basics'>9520: Functional Programming</a></strong> - Functions as mathematical objects</li><li><strong><a href='/12025-10/9530-rich-hickey-simple-made-easy'>9530: Simple Made Easy</a></strong> - Design philosophy<h2></h2></li></ul><h2>What Is a Type?</h2><p><strong>Informal definition</strong>: A type is a <strong>collection of values</strong> that share common properties.</p><p><strong>Examples</strong>:</p><ul><li><strong>Integer</strong>: {..., -2, -1, 0, 1, 2, ...}</li><li><strong>Boolean</strong>: {true, false}</li><li><strong>String</strong>: {\"\", \"a\", \"hello\", \"üåô\", ...}</li></ul><p><strong>In mathematics</strong>: Types are <strong>sets</strong>.</p><p><strong>In programming</strong>: Types <strong>classify</strong> what operations are valid:</p><pre><code class=\"clojure\">;; Integer: can add, multiply\n&#40;+ 3 5&#41;  ; =&gt; 8\n\n;; String: can concatenate, can't add\n&#40;+ &quot;hello&quot; &quot;world&quot;&#41;  ; Error! &#40;in typed languages&#41;\n&#40;str &quot;hello&quot; &quot;world&quot;&#41;  ; =&gt; &quot;helloworld&quot; &#40;correct operation&#41;\n</code></pre><p><strong>Types prevent nonsense operations.</strong><h2></h2></p><h2>Sets: The Mathematical Foundation</h2><p><strong>Set theory</strong> (Georg Cantor, 1870s) underlies all mathematics‚Äîand programming.</p><h3>Basic Sets</h3><p><strong>Natural numbers</strong>: ‚Ñï = {0, 1, 2, 3, ...}</p><p><strong>Integers</strong>: ‚Ñ§ = {..., -2, -1, 0, 1, 2, ...}</p><p><strong>Real numbers</strong>: ‚Ñù = {œÄ, ‚àö2, -5.7, ...}</p><p><strong>Booleans</strong>: ùîπ = {true, false}</p><h3>Set Operations</h3><p><strong>Union</strong> (A ‚à™ B): Elements in A <strong>or</strong> B</p><pre><code>{1, 2} ‚à™ {2, 3} = {1, 2, 3}\n</code></pre><p><strong>Intersection</strong> (A ‚à© B): Elements in A <strong>and</strong> B</p><pre><code>{1, 2} ‚à© {2, 3} = {2}\n</code></pre><p><strong>Cartesian Product</strong> (A √ó B): Pairs from A and B</p><pre><code>{1, 2} √ó {a, b} = {&#40;1,a&#41;, &#40;1,b&#41;, &#40;2,a&#41;, &#40;2,b&#41;}\n</code></pre><p><strong>Programming parallel</strong>:<pre><code class=\"clojure\">;; Union: &quot;or&quot; types &#40;we'll see this in sum types&#41;\n;; Intersection: &quot;and&quot; types &#40;refinement types&#41;\n;; Product: tuples, records, structs\n</code></pre></p><h2></h2><h2>Types in Programming</h2><h3>Primitive Types</h3><p><strong>Most languages have</strong>:</p><pre><code>Integer:  42, -17, 0\nFloat:    3.14, -0.5\nBoolean:  true, false\nCharacter: 'a', 'Â≠ó', 'üåô'\nString:   &quot;hello valley&quot;\n</code></pre><p><strong>These are built-in.</strong> Everything else is composed from these.</p><h3>Composite Types</h3><p><strong>Product types</strong> (A <strong>and</strong> B):<pre><code class=\"clojure\">;; Tuple &#40;ordered pair&#41;\n&#91;42 &quot;Alice&quot;&#93;  ; Integer AND String\n\n;; Record/Map &#40;labeled fields&#41;\n{:name &quot;Alice&quot; :age 30}  ; String AND Integer &#40;labeled&#41;\n</code></pre></p><p><strong>Product = Cartesian product</strong> (all combinations).</p><p><strong>Sum types</strong> (A <strong>or</strong> B):<pre><code class=\"haskell\">-- Haskell &#40;has native sum types&#41;\ndata Result = Success Int | Failure String\n\n-- Value is EITHER Success&#40;42&#41; OR Failure&#40;&quot;error&quot;&#41;\n-- Never both!\n</code></pre></p><p><strong>Sum = union</strong> (one of several options).</p><p>(Clojure doesn't have native sum types, but can encode them with maps: <code>{:type :success :value 42}</code>)<h2></h2></p><h2>Static vs Dynamic Typing</h2><p><strong>The great debate</strong>: Should types be checked at compile-time or runtime?</p><h3>Static Typing</h3><p><strong>Examples</strong>: Java, Haskell, Rust, TypeScript</p><p><strong>Type errors caught before running</strong>:<pre><code class=\"rust\">fn add&#40;x: i32, y: i32&#41; -&gt; i32 {\n    x + y\n}\n\nadd&#40;3, &quot;hello&quot;&#41;  // Compile error: expected i32, got &amp;str\n</code></pre></p><p><strong>Pros</strong>:</p><ul><li><strong>Catch errors early</strong> (before production)</li><li><strong>Documentation</strong> (types describe what functions expect/return)</li><li><strong>IDE support</strong> (autocomplete knows what methods exist)</li><li><strong>Performance</strong> (no runtime type checks)</li></ul><p><strong>Cons</strong>:</p><ul><li><strong>Verbosity</strong> (must declare types)</li><li><strong>Rigidity</strong> (some valid programs rejected)</li><li><strong>Learning curve</strong> (type systems can be complex)</li></ul><h3>Dynamic Typing</h3><p><strong>Examples</strong>: Python, JavaScript, Clojure, Ruby</p><p><strong>Type errors caught when code runs</strong>:<pre><code class=\"python\">def add&#40;x, y&#41;:\n    return x + y\n\nadd&#40;3, &quot;hello&quot;&#41;  # Runtime error: unsupported operand types\n</code></pre></p><p><strong>Pros</strong>:</p><ul><li><strong>Concise</strong> (no type annotations)</li><li><strong>Flexible</strong> (duck typing: \"if it quacks like a duck...\")</li><li><strong>REPL-friendly</strong> (rapid experimentation)</li><li><strong>Simpler</strong> (fewer language features)</li></ul><p><strong>Cons</strong>:</p><ul><li><strong>Runtime errors</strong> (bugs in production)</li><li><strong>Less documentation</strong> (what does this function expect?)</li><li><strong>Slower</strong> (runtime type checks)</li><li><strong>Refactoring harder</strong> (compiler doesn't help find all usages)</li></ul><h3>The Middle Ground</h3><p><strong>Gradual typing</strong>: Optional types (TypeScript, Python type hints, Clojure spec).</p><pre><code class=\"typescript\">// TypeScript: add types to JavaScript\nfunction add&#40;x: number, y: number&#41;: number {\n    return x + y;\n}\n\nadd&#40;3, 5&#41;  // OK\nadd&#40;3, &quot;hello&quot;&#41;  // Error!\n</code></pre><pre><code class=\"clojure\">;; Clojure spec: runtime validation\n&#40;require '&#91;clojure.spec.alpha :as s&#93;&#41;\n\n&#40;s/def ::age &#40;s/and int? #&#40;&gt;= % 0&#41;&#41;&#41;\n&#40;s/def ::user &#40;s/keys :req-un &#91;::name ::age&#93;&#41;&#41;\n\n&#40;s/valid? ::user {:name &quot;Alice&quot; :age 30}&#41;  ; =&gt; true\n&#40;s/valid? ::user {:name &quot;Bob&quot; :age -5}&#41;    ; =&gt; false\n</code></pre><p><strong>Best of both worlds</strong>: Flexibility of dynamic + safety of static (when you want it).<h2></h2></p><h2>Algebraic Data Types</h2><p><strong>\"Algebraic\"</strong> = composed using algebra-like operations (product, sum).</p><h3>Product Types (AND)</h3><p><strong>Tuple</strong>:<pre><code class=\"haskell\">-- Haskell\ntype Point = &#40;Int, Int&#41;\n\n-- Value: &#40;3, 5&#41;\n-- Has TWO components &#40;x AND y&#41;\n</code></pre></p><p><strong>Record</strong>:<pre><code class=\"clojure\">;; Clojure\n{:x 3 :y 5}\n\n;; Has TWO labeled fields\n</code></pre></p><p><strong>Cardinality</strong> (size of set):</p><pre><code>|Bool| = 2  &#40;true, false&#41;\n|Int| = ‚àû  &#40;unbounded integers&#41;\n\n|Bool √ó Int| = 2 √ó ‚àû = ‚àû  &#40;product = multiplication&#41;\n</code></pre><h3>Sum Types (OR)</h3><p><strong>Enumeration</strong>:<pre><code class=\"rust\">// Rust\nenum Status {\n    Pending,\n    Approved,\n    Rejected\n}\n\n// Value is ONE OF: Pending OR Approved OR Rejected\n</code></pre></p><p><strong>Tagged union</strong>:<pre><code class=\"haskell\">-- Haskell\ndata Maybe a = Nothing | Just a\n\n-- Value is EITHER Nothing OR Just&#40;value&#41;\n</code></pre></p><p><strong>Cardinality</strong>:</p><pre><code>|Status| = 3  &#40;three options&#41;\n|Maybe Bool| = 1 + 2 = 3  &#40;Nothing OR Just true OR Just false&#41;\n\n|Sum| = |A| + |B|  &#40;sum = addition&#41;\n</code></pre><p><strong>Why \"algebraic\"</strong>: Types combine via <strong>arithmetic</strong>!<h2></h2></p><h2>Types Prevent Errors</h2><h3>Example: Optional Values</h3><p><strong>Problem</strong>: Handling missing data.</p><p><strong>Bad</strong> (no types, null everywhere):<pre><code class=\"javascript\">function getUser&#40;id&#41; {\n    return database.find&#40;id&#41;;  // Might return null!\n}\n\nconst user = getUser&#40;42&#41;;\nconsole.log&#40;user.name&#41;;  // CRASH if user is null!\n</code></pre></p><p><strong>Billion-dollar mistake</strong> (Tony Hoare invented null in 1965, called it his \"billion-dollar mistake\").</p><p><strong>Good</strong> (types enforce handling):<pre><code class=\"rust\">// Rust: Option type\nfn get&#95;user&#40;id: u32&#41; -&gt; Option&lt;User&gt; {\n    database.find&#40;id&#41;\n}\n\nmatch get&#95;user&#40;42&#41; {\n    Some&#40;user&#41; =&gt; println!&#40;&quot;{}&quot;, user.name&#41;,\n    None =&gt; println!&#40;&quot;User not found&quot;&#41;\n}\n\n// Compiler forces you to handle None case!\n</code></pre></p><p><strong>Even better</strong> (Haskell with Maybe):<pre><code class=\"haskell\">-- Type signature documents possibility of absence\ngetUser :: Int -&gt; Maybe User\n\n-- Must pattern match\ncase getUser 42 of\n    Just user -&gt; userName user\n    Nothing -&gt; &quot;Unknown&quot;\n</code></pre></p><p><strong>Types make absence explicit</strong> (can't forget to check).<h2></h2></p><h2>Function Types</h2><p><strong>Functions have types too</strong>:</p><pre><code class=\"haskell\">-- Haskell type signature\nadd :: Int -&gt; Int -&gt; Int\nadd x y = x + y\n\n-- Reads: &quot;add takes Int, takes another Int, returns Int&quot;\n</code></pre><p><strong>Arrow notation</strong> (‚Üí):</p><pre><code>f :: A ‚Üí B   ; Function from A to B\ng :: B ‚Üí C   ; Function from B to C\ng ‚àò f :: A ‚Üí C   ; Composition &#40;feeds A to f, result to g, produces C&#41;\n</code></pre><p><strong>This is category theory</strong>: Functions are <strong>morphisms</strong> between types (objects).</p><p>(We'll explore this in Essay 9730: Category Theory)</p><h3>Higher-Order Function Types</h3><pre><code class=\"haskell\">-- map takes a function &#40;a ‚Üí b&#41; and a list &#91;a&#93;, returns list &#91;b&#93;\nmap :: &#40;a -&gt; b&#41; -&gt; &#91;a&#93; -&gt; &#91;b&#93;\n\n-- Examples:\nmap :: &#40;Int -&gt; String&#41; -&gt; &#91;Int&#93; -&gt; &#91;String&#93;\nmap show &#91;1,2,3&#93;  -- =&gt; &#91;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#93;\n</code></pre><p><strong>The type signature is documentation</strong>: \"Give me a transformer and a list, I'll transform every element.\"<h2></h2></p><h2>The Curry-Howard Correspondence</h2><p><strong>Mind-bending connection</strong> between logic and types:</p><pre><code>Logic           ‚Üî  Programming\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nProposition     ‚Üî  Type\nProof           ‚Üî  Program\nTheorem         ‚Üî  Type signature\n\n&quot;A implies B&quot;   ‚Üî  Function type A ‚Üí B\n&quot;A and B&quot;       ‚Üî  Product type A √ó B  \n&quot;A or B&quot;        ‚Üî  Sum type A + B\n</code></pre><p><strong>Example</strong>:</p><p><strong>Proposition</strong>: \"If you give me an integer, I can give you a string.\"</p><p><strong>Type</strong>: <code>Int ‚Üí String</code></p><p><strong>Proof</strong>: Write a function with that type!</p><pre><code class=\"haskell\">intToString :: Int -&gt; String\nintToString n = show n\n\n-- This program IS a proof of the proposition!\n</code></pre><p><strong>Profound implication</strong>: <strong>Programs are proofs.</strong> Types are theorems. Compiling is theorem-checking.</p><p><strong>Constructive mathematics</strong> (build the object to prove existence) <strong>is</strong> programming!<h2></h2></p><h2>Type Inference</h2><p><strong>Some languages infer types</strong> (you don't write them, compiler figures them out):</p><pre><code class=\"haskell\">-- Haskell &#40;no type annotations&#41;\nadd x y = x + y\n\n-- Compiler infers:\nadd :: Num a =&gt; a -&gt; a -&gt; a\n-- &quot;For any numeric type a, add takes a and a, returns a&quot;\n</code></pre><pre><code class=\"ocaml\">&#40;&#42; OCaml &#42;&#41;\nlet add x y = x + y\n\n&#40;&#42; Inferred: int -&gt; int -&gt; int &#42;&#41;\n</code></pre><p><strong>Benefits</strong>:</p><ul><li><strong>Concise</strong> (like dynamic typing)</li><li><strong>Safe</strong> (like static typing)</li><li><strong>Best of both worlds</strong> (write little, get safety)</li></ul><p><strong>Limitation</strong>: Complex types can be hard to infer (need annotations for clarity).<h2></h2></p><h2>Hands-On: Type Thinking</h2><h3>Exercise 1: Determine Types</h3><p><strong>What are the types?</strong></p><pre><code class=\"clojure\">;; 1.\n&#40;defn double &#91;x&#93; &#40;&#42; 2 x&#41;&#41;\n;; Type: Number ‚Üí Number\n\n;; 2.\n&#40;defn first-char &#91;s&#93; &#40;first s&#41;&#41;\n;; Type: String ‚Üí Char &#40;or nil if empty!&#41;\n\n;; 3.\n&#40;defn filter-evens &#91;numbers&#93;\n  &#40;filter even? numbers&#41;&#41;\n;; Type: &#91;Number&#93; ‚Üí &#91;Number&#93;\n\n;; 4.\n&#40;defn apply-twice &#91;f x&#93;\n  &#40;f &#40;f x&#41;&#41;&#41;\n;; Type: &#40;a ‚Üí a&#41; ‚Üí a ‚Üí a  &#40;higher-order!&#41;\n</code></pre><p><strong>Think in types</strong>: Helps reason about what functions can/can't do.<h2></h2></p><h3>Exercise 2: Type-Driven Design</h3><p><strong>Start with the type signature</strong>, then implement:</p><pre><code class=\"haskell\">-- Want: validate user\nvalidateUser :: User -&gt; Either Error User\n\n-- Either Error User means:\n-- - If valid: Right User\n-- - If invalid: Left Error\n\nvalidateUser user =\n    if age user &lt; 0\n        then Left &quot;Negative age&quot;\n        else if null &#40;name user&#41;\n            then Left &quot;Missing name&quot;\n            else Right user\n</code></pre><p><strong>Type guides implementation</strong>: Return type is <code>Either</code>, so must return <code>Left</code> or <code>Right</code>.</p><p><strong>Compiler enforces</strong>: Can't forget error cases.<h2></h2></p><h3>Exercise 3: Cardinality</h3><p><strong>Calculate how many possible values</strong>:</p><pre><code class=\"haskell\">-- 1. Bool\n|Bool| = 2  &#40;true, false&#41;\n\n-- 2. &#40;Bool, Bool&#41;\n|&#40;Bool, Bool&#41;| = 2 √ó 2 = 4  &#40;&#40;T,T&#41;, &#40;T,F&#41;, &#40;F,T&#41;, &#40;F,F&#41;&#41;\n\n-- 3. Either Bool Bool\n|Either Bool Bool| = 2 + 2 = 4  &#40;Left T, Left F, Right T, Right F&#41;\n\n-- 4. Maybe Bool\n|Maybe Bool| = 1 + 2 = 3  &#40;Nothing, Just True, Just False&#41;\n</code></pre><p><strong>Cardinality helps</strong> understand types (how many test cases do you need?).<h2></h2></p><h2>Type Systems in Practice</h2><h3>Weak vs Strong Typing</h3><p><strong>Weak typing</strong> (implicit conversions):<pre><code class=\"javascript\">// JavaScript\n&quot;5&quot; + 3  // =&gt; &quot;53&quot; &#40;string concatenation&#41;\n&quot;5&quot; - 3  // =&gt; 2 &#40;numeric subtraction&#41;\ntrue + 1 // =&gt; 2 &#40;true = 1&#41;\n</code></pre></p><p><strong>Surprises!</strong> The language <strong>coerces</strong> types.</p><p><strong>Strong typing</strong> (no implicit conversions):<pre><code class=\"python\"># Python\n&quot;5&quot; + 3  # TypeError: can't concatenate str and int\n&quot;5&quot; - 3  # TypeError: unsupported operand types\n\n# Must be explicit:\nint&#40;&quot;5&quot;&#41; + 3  # =&gt; 8\n&quot;5&quot; + str&#40;3&#41;  # =&gt; &quot;53&quot;\n</code></pre></p><p><strong>Predictable</strong>: No surprises. Type errors are loud.</p><p><strong>Clojure</strong> (strong, dynamic):<pre><code class=\"clojure\">&#40;+ &quot;5&quot; 3&#41;  ; Error: String cannot be cast to Number\n&#40;+ 5 3&#41;    ; =&gt; 8\n</code></pre></p><h3>Nominal vs Structural Typing</h3><p><strong>Nominal</strong> (Java, C++): Types have <strong>names</strong>, names matter.</p><pre><code class=\"java\">class UserId { int value; }\nclass ProductId { int value; }\n\nUserId u = new UserId&#40;42&#41;;\nProductId p = u;  // Error! Different names, even though structure is identical\n</code></pre><p><strong>Structural</strong> (TypeScript, Go): Types defined by <strong>shape</strong>, names don't matter.</p><pre><code class=\"typescript\">// TypeScript\ntype Point = { x: number; y: number };\ntype Vec2 = { x: number; y: number };\n\nconst p: Point = { x: 3, y: 5 };\nconst v: Vec2 = p;  // OK! Same structure\n</code></pre><p><strong>Trade-offs</strong>:</p><ul><li><strong>Nominal</strong>: More explicit (UserId ‚â† ProductId, even if both are ints)</li><li><strong>Structural</strong>: More flexible (if shapes match, types match)<h2></h2></li></ul><h2>Type Safety</h2><p><strong>Type-safe languages</strong> guarantee: <strong>No type errors at runtime</strong> (if compiler accepts, program won't crash due to type mismatch).</p><h3>Sound Type Systems</h3><p><strong>Sound</strong>: If compiler accepts, <strong>no type errors</strong> will occur.</p><p><strong>Examples</strong>: Haskell, Rust, ML</p><p><strong>Benefits</strong>: <strong>Trust the compiler</strong>. If it compiles, types are correct.</p><h3>Unsound Type Systems</h3><p><strong>Unsound</strong>: Compiler accepts, but type errors <strong>might</strong> occur.</p><p><strong>Examples</strong>: Java (null can inhabit any type), TypeScript (explicit <code>any</code> escape hatch)</p><pre><code class=\"java\">String s = null;  // null is &quot;subtype&quot; of all types &#40;unsound!&#41;\ns.length&#40;&#41;;  // NullPointerException at runtime\n</code></pre><p><strong>Trade-off</strong>: Pragmatism (Java's null) vs purity (Haskell's Maybe).<h2></h2></p><h2>Why Types Matter</h2><h3>1. Documentation</h3><p><strong>Type signature documents behavior</strong>:</p><pre><code class=\"haskell\">map :: &#40;a -&gt; b&#41; -&gt; &#91;a&#93; -&gt; &#91;b&#93;\n\n-- Reads: &quot;Give me a function from any type a to any type b,\n--         and a list of a's,\n--         and I'll give you a list of b's.&quot;\n</code></pre><p><strong>You know what <code>map</code> does</strong> without reading implementation!</p><h3>2. Catch Errors Early</h3><pre><code class=\"rust\">fn divide&#40;x: i32, y: i32&#41; -&gt; i32 {\n    x / y\n}\n\ndivide&#40;10, 0&#41;  // Compiles &#40;but crashes at runtime‚Äîdivision by zero&#41;\n\n// Better: use Option to make failure explicit\nfn divide&#95;safe&#40;x: i32, y: i32&#41; -&gt; Option&lt;i32&gt; {\n    if y == 0 {\n        None\n    } else {\n        Some&#40;x / y&#41;\n    }\n}\n\n// Type forces caller to handle None case!\n</code></pre><h3>3. Enable Refactoring</h3><p><strong>Change a type</strong> ‚Üí compiler finds <strong>all</strong> places that need updating.</p><pre><code class=\"haskell\">-- Change User type\ndata User = User String Int  -- name, age\n\n-- Add email field\ndata User = User String Int String  -- Compiler error at every usage site!\n\n-- Must update all pattern matches &#40;compiler guides you&#41;\n</code></pre><p><strong>Without types</strong>: Must manually search, might miss some usages.</p><h3>4. Guide Design</h3><p><strong>Types constrain</strong> what you can build (in a good way).</p><pre><code class=\"haskell\">-- Can't compile this:\nreverse :: &#91;a&#93; -&gt; &#91;a&#93;\nreverse list = 42  -- Error! Returns Int, but signature says &#91;a&#93;\n\n-- Must implement correctly:\nreverse &#91;&#93; = &#91;&#93;\nreverse &#40;x:xs&#41; = reverse xs ++ &#91;x&#93;\n</code></pre><p><strong>Types force correctness.</strong><h2></h2></p><h2>Practical Type Wisdom</h2><h3>When to Use Static Typing</h3><p><strong>Choose static types when</strong>:</p><ul><li>Large codebase (refactoring support)</li><li>Multiple developers (types as contracts)</li><li>Critical systems (catch errors early)</li><li>Long-lived code (types as documentation)</li></ul><p><strong>Examples</strong>: Rust (systems programming), Haskell (finance, compilers), TypeScript (large JS projects)</p><h3>When to Use Dynamic Typing</h3><p><strong>Choose dynamic types when</strong>:</p><ul><li>Prototyping (rapid iteration)</li><li>Scripts (small, short-lived)</li><li>REPL-driven development (experimentation)</li><li>Flexibility matters (heterogeneous data)</li></ul><p><strong>Examples</strong>: Python (data science, scripting), Clojure (REPL-driven web apps), JavaScript (small projects)</p><h3>The Valley's Position</h3><p><strong>We use both</strong>:</p><ul><li><strong>Clojure</strong> (dynamic) for build scripts (flexibility, REPL)</li><li><strong>Nix</strong> (mostly untyped, but pure functions) for builds (determinism)</li><li><strong>Rust</strong> (static) for performance-critical code (safety + speed)</li><li><strong>TypeScript</strong> (gradual) for browser code (catch bugs, gradual adoption)</li></ul><p><strong>Principle</strong>: <strong>Choose the right tool</strong>. No dogma. Evaluate trade-offs.<h2></h2></p><h2>Try This</h2><h3>Exercise 1: Type Signatures in Your Head</h3><p><strong>For functions you write</strong>, think about types:</p><pre><code class=\"python\"># Python &#40;dynamic, but think in types&#41;\ndef process&#95;orders&#40;orders&#41;:\n    return &#91;o for o in orders if o&#91;'total'&#93; &gt; 100&#93;\n\n# Type &#40;imaginary&#41;: &#91;Order&#93; -&gt; &#91;Order&#93;\n# Constraint: orders must have 'total' field &#40;partial function!&#41;\n</code></pre><p><strong>Better</strong> (make constraint explicit):<pre><code class=\"python\">def process&#95;orders&#40;orders: List&#91;Order&#93;&#41; -&gt; List&#91;Order&#93;:\n    return &#91;o for o in orders if o.total &gt; 100&#93;\n</code></pre></p><p><strong>Type annotations help</strong> even in dynamic languages (documentation + IDE support).<h2></h2></p><h3>Exercise 2: Design with Types</h3><p><strong>Problem</strong>: Represent a traffic light.</p><p><strong>Bad</strong> (stringly-typed):<pre><code class=\"clojure\">&#40;def light &quot;red&quot;&#41;  ; What if someone writes &quot;blue&quot;?\n</code></pre></p><p><strong>Good</strong> (keyword enum):<pre><code class=\"clojure\">&#40;def light :red&#41;  ; One of: :red, :yellow, :green\n\n&#40;defn next-light &#91;light&#93;\n  &#40;case light\n    :red :green\n    :yellow :red\n    :green :yellow&#41;&#41;\n</code></pre></p><p><strong>Even better</strong> (Rust with enums):<pre><code class=\"rust\">enum Light { Red, Yellow, Green }\n\nfn next&#95;light&#40;light: Light&#41; -&gt; Light {\n    match light {\n        Light::Red =&gt; Light::Green,\n        Light::Yellow =&gt; Light::Red,\n        Light::Green =&gt; Light::Yellow,\n    }\n}\n\n// Compiler ensures: all cases handled!\n</code></pre></p><h2></h2><h3>Exercise 3: Explore clojure.spec</h3><pre><code class=\"clojure\">&#40;require '&#91;clojure.spec.alpha :as s&#93;&#41;\n\n;; Define specs &#40;types, but at runtime&#41;\n&#40;s/def ::age &#40;s/and int? #&#40;&gt;= % 0&#41; #&#40;&lt;= % 150&#41;&#41;&#41;\n&#40;s/def ::email &#40;s/and string? #&#40;re-matches #&quot;.+@.+&quot; %&#41;&#41;&#41;\n&#40;s/def ::user &#40;s/keys :req-un &#91;::age ::email&#93;&#41;&#41;\n\n;; Validate\n&#40;s/valid? ::user {:age 30 :email &quot;alice@example.com&quot;}&#41;  ; =&gt; true\n&#40;s/valid? ::user {:age -5 :email &quot;invalid&quot;}&#41;  ; =&gt; false\n\n;; Explain why invalid\n&#40;s/explain ::user {:age -5 :email &quot;invalid&quot;}&#41;\n; -5 - failed: &#40;&gt;= % 0&#41;\n; &quot;invalid&quot; - failed: &#40;re-matches #&quot;.+@.+&quot; %&#41;\n</code></pre><p><strong>Gradual typing</strong>: Add specs where you want validation, skip where you want flexibility.<h2></h2></p><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9520-functional-programming-basics'>9520: Functional Programming</a></strong> - Functions as typed objects</li><li><strong><a href='/12025-10/9701-lie-groups-continuous-symmetries'>9701: Lie Groups</a></strong> - Mathematical structures (types are sets with structure!)</li><li><strong><a href='/12025-10/9730-category-theory-for-programmers'>9730: Category Theory</a></strong> - Types as objects, functions as morphisms</li><li><strong>Phase 3</strong> - Advanced type theory (~9710-9720)</li></ul><h3>External Resources</h3><ul><li><strong>\"Types and Programming Languages\"</strong> by Benjamin Pierce - Comprehensive textbook</li><li><strong>\"Propositions as Types\"</strong> by Philip Wadler - Curry-Howard explained beautifully</li><li><strong>Haskell</strong> - Learn You a Haskell (pure functional + strong types)</li><li><strong>Rust Book</strong> - Ownership types (unique to Rust)</li></ul><h3>For the Mathematically Curious</h3><ul><li><strong>Set theory</strong> - Cantor, ZFC axioms</li><li><strong>Type theory</strong> - Russell, Church, Martin-L√∂f</li><li><strong>Category theory</strong> - Types as objects, programs as morphisms<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Are types primarily for the compiler or for humans?</strong> (Both! But which matters more?)</li><li><strong>Is dynamic typing \"simpler\" than static typing?</strong> (Depends on definition of simple‚Äîfewer language features, but more runtime complexity)</li><li><strong>Should all programs be formally verified?</strong> (Ideal but impractical‚Äîwhat's the trade-off?)</li><li><strong>Can types replace tests?</strong> (No‚Äîbut they eliminate whole classes of tests)</li><li><strong>Is TypeScript worth it for JavaScript projects?</strong> (Depends on size, team, longevity)<h2></h2></li></ol><h2>Summary</h2><p><strong>Types are</strong>:</p><ul><li><strong>Sets of values</strong> (mathematical foundation)</li><li><strong>Classifications</strong> preventing invalid operations</li><li><strong>Documentation</strong> (signatures describe behavior)</li><li><strong>Proofs</strong> (Curry-Howard: programs prove theorems)</li></ul><p><strong>Key Concepts</strong>:</p><ul><li><strong>Product types</strong> (A AND B) - tuples, records, structs</li><li><strong>Sum types</strong> (A OR B) - enums, tagged unions, Maybe/Option</li><li><strong>Algebraic</strong> (combine via arithmetic: √ó for product, + for sum)</li><li><strong>Static vs dynamic</strong> (compile-time vs runtime checking)</li><li><strong>Soundness</strong> (guaranteed safety vs pragmatic escapes)</li></ul><p><strong>Benefits</strong>:</p><ul><li><strong>Catch errors early</strong> (before production)</li><li><strong>Guide refactoring</strong> (compiler finds all usages)</li><li><strong>Document intent</strong> (types as specifications)</li><li><strong>Enable tooling</strong> (autocomplete, go-to-definition)</li></ul><p><strong>Trade-offs</strong>:</p><ul><li><strong>Static</strong>: Safety + documentation, but verbosity + rigidity</li><li><strong>Dynamic</strong>: Concise + flexible, but runtime errors + less tooling</li><li><strong>Gradual</strong>: Middle ground (TypeScript, Python hints, Clojure spec)</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>We use both paradigms</strong> (Clojure dynamic, Rust static)</li><li><strong>Types as contracts</strong> (even in dynamic languages, think in types)</li><li><strong>Simplicity over ceremony</strong> (use types when they help, skip when they don't)</li><li><strong>Mathematics as foundation</strong> (types are sets, programs are proofs)<h2></h2></li></ul><p><strong>Next</strong>: We'll explore <strong>the command line</strong>‚Äîyour primary interface to Unix systems, where you'll apply the text-oriented, compositional thinking we've been building!<h2></h2></p><p><strong>Navigation</strong>:<br /> ‚Üê Previous: <a href='/12025-10/9530-rich-hickey-simple-made-easy'>9530 (rich hickey simple made easy)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9550-command-line-your-primary-interface'>9550 (command line your primary interface)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 3</li><li><strong>Prerequisites</strong>: 9500, 9520, 9530</li><li><strong>Concepts</strong>: Types, sets, static/dynamic typing, algebraic data types, Curry-Howard, type inference</li><li><strong>Next Concepts</strong>: Command line, shell, text processing, Unix tools mastery</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright ¬© 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.429138781Z-21479"
}