;;; âœ§ï½¥ï¾Ÿ:* graintime-validator.ket - validate graintime across entire repository
;;;
;;; team: 10 (teamstructure10 - capricorn â™‘ / x. wheel of fortune)
;;; authored by: 14 (teamdescend14 - ketu â˜‹ / xiv. temperance)
;;;
;;; purpose: recursively validate all graintime strings in repository,
;;;          checking format compliance and astronomical consistency
;;;          for dates from 12025 (holocene year 2025) through 12099+
;;;
;;; this validator checks:
;;;   1. 76-character format compliance
;;;   2. valid date ranges (year, month, day)
;;;   3. valid time ranges (hour, minute)
;;;   4. valid timezone abbreviations
;;;   5. valid nakshatra names and abbreviations
;;;   6. valid zodiac signs and degrees (0-30)
;;;   7. valid solar houses (1-12)
;;;   8. valid team names and padding
;;;   9. logical consistency (can we verify this date existed?)
;;;  10. astronomical plausibility (moon/asc/sun relationships)
;;;
;;; âˆ¿âˆ¿âˆ¿ validation as epistemic hygiene âˆ¿âˆ¿âˆ¿

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; validation result types (algebraic data type via maps)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

;; âœ¿ Result<T, E> = {:ok T} | {:error E} âœ¿
;;
;; this is our result type inspired by rust's Result<T, E> and haskell's Either.
;; validation functions return either {:ok value} or {:error reason}.
;; we compose these through monadic bind (flatmap in clojure parlance).

(define (ok value)
  ;; :: a â†’ Result a e
  ;; construct successful validation result
  {:ok value :valid? true})

(define (error reason)
  ;; :: e â†’ Result a e
  ;; construct failed validation result with reason
  {:error reason :valid? false})

(define (result-ok? r)
  ;; :: Result a e â†’ Boolean
  ;; check if result represents success
  (get r :valid? false))

(define (result-error? r)
  ;; :: Result a e â†’ Boolean
  ;; check if result represents error
  (not (result-ok? r)))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; graintime format specification (76 characters)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

;; format: 12025-10-27--0145-PDT--moon-p_ashadha----asc-leo023-sun-03h----teamdescend14
;;         â””â”€dateâ”€â”€â”˜  â””timeâ”¤ â””tzâ”¤  â””â”€nakshatraâ”€â”€â”˜â””ascendantâ”˜â””houseâ”€â”˜â””â”€â”€â”€teamâ”€â”€â”€â”˜
;;         11 chars   4     3      18 chars       10         8        17
;;         Total: 11 + 4 + 3 + 18 + 10 + 8 + 17 + 5 dashes = 76 chars

(define graintime-regex
  ;; regex pattern matching valid 76-char graintime
  ;; this is our grammar encoded as regular expression
  "^(1[0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])--(0[0-9]|1[0-9]|2[0-3])([0-5][0-9])-([A-Z]{3})--moon-([a-z_]{1,12}-+)asc-([a-z]{4})([0-3][0-9])-sun-(0[1-9]|1[0-2])h(-+team[a-z]+1[0-4])$")

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; valid values (from vedic astronomy and grain network spec)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define valid-nakshatras
  ;; âœ¿ 27 lunar mansions of vedic astrology âœ¿
  #{"ashwini" "bharani" "krittika" "rohini" "mrigashira" "ardra"
    "punarvasu" "pushya" "ashlesha" "magha" "p_phalguni" "u_phalguni"
    "hasta" "chitra" "swati" "vishakha" "anuradha" "jyeshtha"
    "mula" "p_ashadha" "u_ashadha" "shravana" "dhanishta"
    "shatabhisha" "p_bhadrapada" "u_bhadrapada" "revati"})

(define valid-zodiac-signs
  ;; âœ¿ 12 rashi (zodiac signs) âœ¿
  #{"arie" "taur" "gemi" "canc" "leo0" "virg"
    "libr" "scor" "sagi" "capr" "aqua" "pisc"})

(define valid-timezones
  ;; common timezone abbreviations (expand as needed)
  #{"PDT" "PST" "CDT" "CST" "EDT" "EST" "MDT" "MST"
    "UTC" "GMT" "IST" "JST" "CET" "EET"})

(define valid-teams
  ;; 14 grain network teams
  #{"supreme" "nurture" "transform" "descend" "flow"
    "structure" "precision" "ascend" "power" "ground"
    "air" "water" "fire" "earth"})

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; component validators (each checks one piece)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (validate-graintime-length graintime)
  ;; :: String â†’ Result String String
  ;;
  ;; check that graintime is exactly 76 characters.
  ;; this is the foundational structural requirement.
  
  (let ((len (string-length graintime)))
    (if (equal? 76 len)
        (ok graintime)
        (error (format "invalid length: expected 76, got {}" len)))))

(define (validate-year year-str)
  ;; :: String â†’ Result Integer String
  ;;
  ;; validate holocene calendar year (12025+).
  ;; we support 12025-12999 (years 2025-2999 CE).
  
  (let ((year (string->number year-str)))
    (if (and (>= year 12025) (<= year 12999))
        (ok year)
        (error (format "invalid year: {} (must be 12025-12999)" year)))))

(define (validate-month month-str)
  ;; :: String â†’ Result Integer String
  ;;
  ;; validate month (01-12).
  
  (let ((month (string->number month-str)))
    (if (and (>= month 1) (<= month 12))
        (ok month)
        (error (format "invalid month: {} (must be 01-12)" month)))))

(define (validate-day day-str month)
  ;; :: String â†’ Integer â†’ Result Integer String
  ;;
  ;; validate day (01-31) accounting for month lengths.
  ;; we use simplified validation (not checking leap years yet).
  
  (let ((day (string->number day-str))
        (max-day (cond
                   ((member? month '(1 3 5 7 8 10 12)) 31)
                   ((member? month '(4 6 9 11)) 30)
                   (else 29)))) ; february (simplified)
    (if (and (>= day 1) (<= day max-day))
        (ok day)
        (error (format "invalid day: {} for month {} (max {})" day month max-day)))))

(define (validate-hour hour-str)
  ;; :: String â†’ Result Integer String
  ;;
  ;; validate hour (00-23).
  
  (let ((hour (string->number hour-str)))
    (if (and (>= hour 0) (<= hour 23))
        (ok hour)
        (error (format "invalid hour: {} (must be 00-23)" hour)))))

(define (validate-minute minute-str)
  ;; :: String â†’ Result Integer String
  ;;
  ;; validate minute (00-59).
  
  (let ((minute (string->number minute-str)))
    (if (and (>= minute 0) (<= minute 59))
        (ok minute)
        (error (format "invalid minute: {} (must be 00-59)" minute)))))

(define (validate-timezone tz)
  ;; :: String â†’ Result String String
  ;;
  ;; validate timezone abbreviation.
  
  (if (member? tz valid-timezones)
      (ok tz)
      (error (format "invalid timezone: {} (not in known set)" tz))))

(define (validate-nakshatra nak-with-padding)
  ;; :: String â†’ Result String String
  ;;
  ;; validate nakshatra abbreviation (with padding).
  ;; strip trailing dashes and check against valid set.
  
  (let ((nak (string-trim-right nak-with-padding #\-)))
    (if (member? nak valid-nakshatras)
        (ok nak)
        (error (format "invalid nakshatra: {} (not in 27 lunar mansions)" nak)))))

(define (validate-zodiac-sign sign)
  ;; :: String â†’ Result String String
  ;;
  ;; validate zodiac sign abbreviation (4 chars).
  
  (if (member? sign valid-zodiac-signs)
      (ok sign)
      (error (format "invalid zodiac sign: {} (not in 12 rashi)" sign))))

(define (validate-degree degree-str)
  ;; :: String â†’ Result Integer String
  ;;
  ;; validate astrological degree (00-30).
  ;; note: 30Â° is edge case (0Â° of next sign), we allow it.
  
  (let ((degree (string->number degree-str)))
    (if (and (>= degree 0) (<= degree 30))
        (ok degree)
        (error (format "invalid degree: {} (must be 00-30)" degree)))))

(define (validate-solar-house house-str)
  ;; :: String â†’ Result Integer String
  ;;
  ;; validate solar house (01-12).
  
  (let ((house (string->number house-str)))
    (if (and (>= house 1) (<= house 12))
        (ok house)
        (error (format "invalid house: {} (must be 01-12)" house)))))

(define (validate-team team-with-padding)
  ;; :: String â†’ Result String String
  ;;
  ;; validate team name (strip leading dashes and "team" prefix).
  
  (let* ((team-part (string-trim-left team-with-padding #\-))
         (base (if (string-prefix? "team" team-part)
                   (substring team-part 4 (- (string-length team-part) 2))
                   team-part)))
    (if (member? base valid-teams)
        (ok base)
        (error (format "invalid team: {} (not in 14 teams)" base)))))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; padding validators (check exact spacing)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (validate-nakshatra-padding nak-with-padding)
  ;; :: String â†’ Result String String
  ;;
  ;; nakshatra section must be exactly 13 chars (name + trailing dashes).
  
  (if (equal? 13 (string-length nak-with-padding))
      (ok nak-with-padding)
      (error (format "nakshatra padding wrong: got {} chars, need 13" 
                     (string-length nak-with-padding)))))

(define (validate-team-padding team-with-padding)
  ;; :: String â†’ Result String String
  ;;
  ;; team section must be exactly 17 chars (leading dashes + teamXXXX1Y).
  
  (if (equal? 17 (string-length team-with-padding))
      (ok team-with-padding)
      (error (format "team padding wrong: got {} chars, need 17"
                     (string-length team-with-padding)))))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; astronomical consistency checks (advanced validation)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (validate-date-exists year month day)
  ;; :: Integer â†’ Integer â†’ Integer â†’ Result Boolean String
  ;;
  ;; check if date is logically valid (rough check).
  ;; future: could check against actual calendar with leap years.
  
  ;; for now, basic validation (already done in component validators)
  (ok true))

(define (validate-solar-house-for-time hour is-day?)
  ;; :: Integer â†’ Boolean â†’ Result Boolean String
  ;;
  ;; check if solar house makes sense for given time of day.
  ;;
  ;; rough logic:
  ;;   - sunrise (6am): house 1
  ;;   - noon (12pm): house 10
  ;;   - sunset (6pm): house 7
  ;;   - midnight (12am): house 4
  ;;   - morning (6am-12pm): houses 12, 11
  ;;   - afternoon (12pm-6pm): houses 9, 8
  ;;   - evening (6pm-12am): houses 6, 5
  ;;   - night (12am-6am): houses 3, 2
  ;;
  ;; this is simplified - actual calculation depends on sunrise/sunset times
  ;; which vary by date and location. we just do sanity check here.
  
  ;; for now, accept all houses (we'd need ephemeris data to verify precisely)
  (ok true))

(define (validate-moon-nakshatra-plausible nakshatra year month day)
  ;; :: String â†’ Integer â†’ Integer â†’ Integer â†’ Result Boolean String
  ;;
  ;; check if moon in this nakshatra is plausible for this date.
  ;;
  ;; moon completes nakshatra cycle in ~27.3 days.
  ;; we COULD check against ephemeris data, but that requires:
  ;;   - swiss ephemeris library (C code, complex integration)
  ;;   - or API calls (network dependency, slow in CI)
  ;;   - or pre-calculated lookup tables (maintenance burden)
  ;;
  ;; for CI/CD, we choose pragmatic approach:
  ;;   - if we have cached ephemeris data for this date, verify
  ;;   - otherwise, accept as plausible (format is valid)
  ;;
  ;; this is "optimistic validation" - assume good faith unless proven wrong.
  
  ;; TODO: integrate with astroccult cached data or swiss ephemeris
  (ok true))

(define (validate-ascendant-plausible sign degree hour)
  ;; :: String â†’ Integer â†’ Integer â†’ Result Boolean String
  ;;
  ;; check if ascendant is plausible for given hour.
  ;;
  ;; ascendant changes ~1Â° every 4 minutes (full 360Â° in 24 hours).
  ;; at any given hour, certain signs are more likely to be rising
  ;; based on time of day and latitude.
  ;;
  ;; again, precise validation requires:
  ;;   - exact latitude/longitude
  ;;   - exact date for ecliptic position
  ;;   - ephemeris calculations
  ;;
  ;; for CI, we do rough sanity check:
  ;;   - is this a valid zodiac sign? âœ“ (already checked)
  ;;   - is degree in valid range? âœ“ (already checked)
  ;;   - TODO: check if sign makes sense for hour (rough estimate)
  
  ;; for now, accept all (precise validation needs ephemeris)
  (ok true))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; graintime parser (extract components from string)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (parse-graintime graintime)
  ;; :: String â†’ Result GraintimeComponents String
  ;;
  ;; parse graintime string into components for validation.
  ;;
  ;; returns map:
  ;;   {:year "12025" :month "10" :day "27" :hour "01" :minute "45"
  ;;    :timezone "PDT" :nakshatra "p_ashadha----" :asc-sign "leo0"
  ;;    :asc-degree "23" :sun-house "03" :team "----teamdescend14"}
  
  ;; format: 12025-10-27--0145-PDT--moon-p_ashadha----asc-leo023-sun-03h----teamdescend14
  ;;         0....5.7..10..13.15.17..20....24......33...37....43...47..50...54............72..76
  
  (if (not (equal? 76 (string-length graintime)))
      (error (format "wrong length: {} (need 76)" (string-length graintime)))
      
      ;; extract components by position (brittle but precise)
      (let ((year (substring graintime 0 5))
            (month (substring graintime 6 8))
            (day (substring graintime 9 11))
            (hour (substring graintime 13 15))
            (minute (substring graintime 15 17))
            (timezone (substring graintime 18 21))
            (nakshatra (substring graintime 27 40))  ; 13 chars with padding
            (asc-sign (substring graintime 44 48))   ; 4 chars
            (asc-degree (substring graintime 48 50)) ; 2 chars
            (sun-house (substring graintime 55 57))  ; 2 chars
            (team (substring graintime 59 76)))      ; 17 chars with padding
        
        (ok {:year year
             :month month
             :day day
             :hour hour
             :minute minute
             :timezone timezone
             :nakshatra nakshatra
             :asc-sign asc-sign
             :asc-degree asc-degree
             :sun-house sun-house
             :team team}))))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; composed validation (chain all checks together)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (validate-graintime-complete graintime)
  ;; :: String â†’ Result GraintimeComponents [Error]
  ;;
  ;; perform complete validation of graintime string.
  ;; returns either {:ok components} or {:error [reasons]}.
  ;;
  ;; this is our validation chain - a sequence of predicates composed
  ;; through monadic bind. each check depends on previous success.
  ;;
  ;; functorial composition: we lift pure validation functions into
  ;; the Result monad, allowing error accumulation and short-circuiting.
  
  (let ((errors '()))
    
    ;; 1. check length (must be first - parsing depends on it)
    (let ((length-result (validate-graintime-length graintime)))
      (if (result-error? length-result)
          (error (list (get length-result :error)))
          
          ;; 2. parse components
          (let ((parse-result (parse-graintime graintime)))
            (if (result-error? parse-result)
                (error (list (get parse-result :error)))
                
                ;; 3. validate each component
                (let* ((components (get parse-result :ok))
                       (year-result (validate-year (get components :year)))
                       (month-result (validate-month (get components :month)))
                       (day-result (validate-day (get components :day) 
                                                 (get month-result :ok)))
                       (hour-result (validate-hour (get components :hour)))
                       (minute-result (validate-minute (get components :minute)))
                       (tz-result (validate-timezone (get components :timezone)))
                       (nak-pad-result (validate-nakshatra-padding (get components :nakshatra)))
                       (nak-result (validate-nakshatra (get components :nakshatra)))
                       (sign-result (validate-zodiac-sign (get components :asc-sign)))
                       (degree-result (validate-degree (get components :asc-degree)))
                       (house-result (validate-solar-house (get components :sun-house)))
                       (team-pad-result (validate-team-padding (get components :team)))
                       (team-result (validate-team (get components :team))))
                  
                  ;; collect all errors
                  (let ((all-results (list year-result month-result day-result
                                          hour-result minute-result tz-result
                                          nak-pad-result nak-result
                                          sign-result degree-result house-result
                                          team-pad-result team-result))
                        (errors (filter result-error? all-results)))
                    
                    (if (empty? errors)
                        (ok components)
                        (error (map #(get % :error) errors)))))))))))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; file system scanner (find all graintimes in repo)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define graintime-pattern
  ;; regex to find graintime strings anywhere in files
  ;; matches: 1XXXX-XX-XX--XXXX-XXX--moon-...
  "1[0-9]{4}-[0-9]{2}-[0-9]{2}--[0-9]{4}-[A-Z]{3}--moon-[a-z_-]+asc-[a-z0-9]+-sun-[0-9]{2}h[- ]*team[a-z]+1[0-4]")

(define (scan-file-for-graintimes filepath)
  ;; :: String â†’ [String]
  ;;
  ;; scan a single file for graintime strings.
  ;; returns list of found graintimes.
  
  ;; TODO: implement file reading and regex matching
  ;; this requires ketos io functions
  '())

(define (scan-repo-for-graintimes root-path)
  ;; :: String â†’ [(String, String)]
  ;;
  ;; recursively scan repository for all graintime strings.
  ;; returns list of (filepath, graintime) tuples.
  
  ;; TODO: implement recursive directory traversal
  ;; this requires ketos filesystem functions
  '())

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; validation report (for CI/CD output)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (validate-all-graintimes root-path)
  ;; :: String â†’ ValidationReport
  ;;
  ;; scan entire repo and validate all found graintimes.
  ;;
  ;; returns:
  ;;   {:total-found 42
  ;;    :valid 38
  ;;    :invalid 4
  ;;    :errors [{:file "..." :graintime "..." :reasons [...]}]}
  
  (let ((found (scan-repo-for-graintimes root-path))
        (results (map (lambda (item)
                       (let ((filepath (first item))
                             (graintime (second item))
                             (validation (validate-graintime-complete graintime)))
                         {:file filepath
                          :graintime graintime
                          :valid? (result-ok? validation)
                          :errors (if (result-error? validation)
                                    (get validation :error)
                                    '())}))
                     found))
        (valid-count (count (filter #(get % :valid?) results)))
        (invalid-count (count (filter #(not (get % :valid?)) results))))
    
    {:total-found (count found)
     :valid valid-count
     :invalid invalid-count
     :results results}))

(define (print-validation-report report)
  ;; :: ValidationReport â†’ IO ()
  ;;
  ;; pretty-print validation report for CI/CD output.
  
  (println "")
  (println "âœ§ï½¥ï¾Ÿ:* GRAINTIME VALIDATION REPORT âœ§ï½¥ï¾Ÿ:*")
  (println "")
  (println (format "Total graintimes found: {}" (get report :total-found)))
  (println (format "Valid: {} âœ…" (get report :valid)))
  (println (format "Invalid: {} âŒ" (get report :invalid)))
  (println "")
  
  (let ((invalid (filter #(not (get % :valid?)) (get report :results))))
    (if (not (empty? invalid))
        (do
          (println "âŒ INVALID GRAINTIMES:")
          (println "")
          (for-each (lambda (item)
                     (println (format "File: {}" (get item :file)))
                     (println (format "Graintime: {}" (get item :graintime)))
                     (println "Errors:")
                     (for-each (lambda (err)
                                (println (format "  - {}" err)))
                              (get item :errors))
                     (println ""))
                   invalid))
        (println "âœ… ALL GRAINTIMES VALID! âœ§ï½¥ï¾Ÿ:*")))
  
  (println "")
  (println "now == next + 1 ğŸŒ¾")
  (println ""))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; ci/cd entry point
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (main args)
  ;; :: [String] â†’ Integer
  ;;
  ;; main entry point for ci/cd execution.
  ;; returns exit code: 0 if all valid, 1 if any invalid.
  
  (let* ((root-path (if (empty? args) "." (first args)))
         (report (validate-all-graintimes root-path)))
    
    (print-validation-report report)
    
    ;; exit code: 0 for success, 1 for failure
    (if (equal? 0 (get report :invalid))
        0
        1)))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; exports
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(export validate-graintime-complete
        validate-all-graintimes
        parse-graintime
        main)

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; usage examples
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(comment
  ;; example 1: validate single graintime
  (define test-graintime
    "12025-10-27--0145-PDT--moon-p_ashadha----asc-leo023-sun-03h----teamdescend14")
  
  (define result (validate-graintime-complete test-graintime))
  ;; â†’ {:ok {:year "12025" :month "10" ...} :valid? true}
  
  ;; example 2: invalid graintime (wrong length)
  (define bad-graintime
    "12025-10-27--0145-PDT--moon-mula")
  
  (define bad-result (validate-graintime-complete bad-graintime))
  ;; â†’ {:error ["invalid length: expected 76, got 28"] :valid? false}
  
  ;; example 3: invalid graintime (bad nakshatra)
  (define bad-nak
    "12025-10-27--0145-PDT--moon-invalid------asc-leo023-sun-03h----teamdescend14")
  
  (define bad-nak-result (validate-graintime-complete bad-nak))
  ;; â†’ {:error ["invalid nakshatra: invalid (not in 27 lunar mansions)"] :valid? false}
  
  ;; example 4: run full repo validation (in ci/cd)
  ;; $ ketos graintime-validator.ket /path/to/repo
  ;; â†’ scans all files, validates all graintimes, prints report, exits with code
  )

;;; âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿
;;; implementation notes
;;; âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿
;;;
;;; this validator uses "optimistic validation" philosophy:
;;;   - check format rigorously (76 chars, proper padding, valid components)
;;;   - check astronomical plausibility loosely (without full ephemeris)
;;;   - accept valid-looking graintimes unless proven invalid
;;;
;;; rationale:
;;;   - precise astronomical validation requires:
;;;     * swiss ephemeris (complex C library integration)
;;;     * or astro API calls (network dependency, slow, brittle)
;;;     * or pre-calculated tables (maintenance burden, limited range)
;;;   
;;;   - for CI/CD speed and reliability, we prefer:
;;;     * fast local validation (no network calls)
;;;     * simple dependencies (pure ketos, no C bindings)
;;;     * conservative errors (only fail on clear format violations)
;;;
;;; future enhancements:
;;;   1. integrate swiss ephemeris for precise moon position validation
;;;   2. cache ephemeris data for common date ranges (2025-2030)
;;;   3. add timezone-aware datetime validation
;;;   4. validate sunrise/sunset times for solar house accuracy
;;;   5. cross-check ascendant against local sidereal time
;;;
;;; for now: rigorous format validation + optimistic astronomical validation
;;;
;;; âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿
;;; end of graintime-validator.ket
;;;
;;; now == next + 1 âœ§ï½¥ï¾Ÿ:* ğŸŒ¾
;;;
;;; copyright Â© 2025 kae3g (kj3x39, @risc.love)
;;; team: 10 (teamstructure10)
;;; authored by: 14 (teamdescend14 - ketu â˜‹)
;;; âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿

