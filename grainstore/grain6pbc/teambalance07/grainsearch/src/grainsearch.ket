;; âˆ¿âˆ¿âˆ¿ GRAINSEARCH: FUNCTIONAL SEARCH UTILITY âˆ¿âˆ¿âˆ¿
;; team: 07 (teambalance07 - libra â™ / vii. the chariot)
;; authored by: 14 (teamdescend14 - ketu â˜‹ / xiv. temperance)
;; description: composable search utility for grain processing
;;              purely functional, strongly typed, extensible
;;              balancing power with simplicity

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ TYPE SYSTEM (inspired by algebraic types, not named explicitly) â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

;; search-result :: { :file str, :line-number int, :content str, :fields [str] }
;; search-config :: { :pattern (str -> bool), :field-sep str, :aggregate? bool }
;; pattern-type  :: union { :regex str | :predicate (str -> bool) | :function (str -> any) }
;; aggregate     :: { :count int, :unique #{str}, :sum num, :mean num }

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ CORE DATA CONSTRUCTORS (pure values) â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun make-search-result (file line-num content)
  "construct a search result record"
  {:file file
   :line-number line-num
   :content content
   :fields []
   :matched? false})

(defun make-config (pattern field-sep aggregate?)
  "construct a search configuration record"
  {:pattern pattern
   :field-sep (if (nil? field-sep) " " field-sep)
   :aggregate? aggregate?
   :case-sensitive? true
   :multiline? false})

(defun make-aggregate ()
  "construct an empty aggregation record"
  {:count 0
   :unique #{}
   :sum 0.0
   :values []})

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ PATTERN MATCHING (polymorphic dispatch) â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun pattern-match? (pattern-spec line)
  "polymorphic pattern matcher - dispatches based on pattern type
   pattern-spec can be:
   - string (literal substring match)
   - (hash-map :regex str) (regex pattern)
   - (hash-map :pred fn) (predicate function)
   - function (direct application)"
  (cond
    ;; string literal
    ((string? pattern-spec)
     (string-contains? line pattern-spec))
    
    ;; regex pattern
    ((and (hash-map? pattern-spec) (get :regex pattern-spec))
     (regex-matches? (get :regex pattern-spec) line))
    
    ;; predicate function
    ((and (hash-map? pattern-spec) (get :pred pattern-spec))
     ((get :pred pattern-spec) line))
    
    ;; direct function application
    ((function? pattern-spec)
     (pattern-spec line))
    
    ;; fallback: false
    (else false)))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ FIELD EXTRACTION (columnar splitting) â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun extract-fields (line separator)
  "split line into fields using separator
   returns vector of trimmed field strings"
  (if (string? separator)
      (map string-trim (string-split line separator))
      (list line)))

(defun get-field (fields n)
  "safely get nth field (1-indexed like awk)
   returns empty string if field doesn't exist"
  (if (and (> n 0) (<= n (length fields)))
      (nth fields (- n 1))
      ""))

(defun field-selector (n)
  "create a function that extracts nth field
   returns a closure for functional composition"
  (lambda (line separator)
    (let ((fields (extract-fields line separator)))
      (get-field fields n))))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ AGGREGATION (fold/reduce operations)     â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun aggregate-line (agg line field-num separator)
  "fold a line into aggregation state
   updates count, unique set, sum, and values list"
  (let* ((fields (extract-fields line separator))
         (field-value (get-field fields field-num))
         (numeric-value (string->number field-value)))
    {:count (+ (:count agg) 1)
     :unique (set-add (:unique agg) field-value)
     :sum (if numeric-value
              (+ (:sum agg) numeric-value)
              (:sum agg))
     :values (cons field-value (:values agg))}))

(defun finalize-aggregate (agg)
  "compute final statistics from aggregation state"
  (let ((count (:count agg)))
    (assoc agg :mean
           (if (> count 0)
               (/ (:sum agg) count)
               0.0))))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ GRAIN-SPECIFIC PATTERNS (domain knowledge)â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun graintime-pattern ()
  "pattern matching graintime format (76 chars)
   example: 12025-10-27--0145-PDT--moon-p_ashadha----asc-leo023-sun-03h----teamdescend14"
  {:regex "^[0-9]{5}-[0-9]{2}-[0-9]{2}--[0-9]{4}-[A-Z]{3}--moon-[a-z_]+-+asc-[a-z]{4}[0-9]{3}-sun-[0-9]{2}h-+"})

(defun graincode-pattern ()
  "pattern matching 6-character grain codes
   alphabet: xbdghjklmnsvz (no repeats)"
  {:regex "^[xbdghjklmnsvz]{6}$"})

(defun grain-box-pattern ()
  "pattern matching grain ASCII box borders"
  {:pred (lambda (line)
          (or (string-starts-with? line "â”Œâ”€â”€")
              (string-starts-with? line "â”œâ”€â”€")
              (string-starts-with? line "â””â”€â”€")
              (string-starts-with? line "â”‚ ")))})

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ MAIN SEARCH ENGINE (pipeline composition) â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun search-lines (lines pattern-spec config)
  "search through lines using pattern, return matching results
   purely functional - no side effects"
  (let ((separator (:field-sep config)))
    (filter (lambda (result)
              (:matched? result))
            (map-indexed
             (lambda (idx line)
               (let ((matched? (pattern-match? pattern-spec line)))
                 (if matched?
                     (assoc (make-search-result "stdin" (+ idx 1) line)
                            :matched? true
                            :fields (extract-fields line separator))
                     (make-search-result "stdin" (+ idx 1) line))))
             lines))))

(defun search-file (filepath pattern-spec config)
  "search a file, return matching results
   handles file I/O at boundary"
  (let* ((file-contents (slurp filepath))
         (lines (string-split file-contents "\n"))
         (separator (:field-sep config)))
    (map (lambda (result)
           (assoc result :file filepath))
         (search-lines lines pattern-spec config))))

(defun search-files (filepaths pattern-spec config)
  "search multiple files, return combined results
   composition of search-file over list"
  (mapcat (lambda (filepath)
            (search-file filepath pattern-spec config))
          filepaths))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ OUTPUT FORMATTING (presentation layer) â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun format-result (result show-line-numbers? show-file?)
  "format a search result for display
   pure function: result -> string"
  (let ((file-prefix (if show-file? 
                         (str (:file result) ":")
                         ""))
        (line-prefix (if show-line-numbers?
                         (str (:line-number result) ":")
                         "")))
    (str file-prefix line-prefix (:content result))))

(defun format-aggregate (agg field-name)
  "format aggregation statistics for display"
  (str "count: " (:count agg) "\n"
       "unique: " (set-size (:unique agg)) "\n"
       "sum: " (:sum agg) "\n"
       "mean: " (:mean agg)))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ CLI INTERFACE (command-line boundary) â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun parse-args (args)
  "parse command-line arguments into config
   returns {:pattern, :files, :options}"
  (let ((pattern (first args))
        (files (rest args)))
    {:pattern pattern
     :files (if (empty? files) ["stdin"] files)
     :field-sep " "
     :aggregate? false
     :show-line-numbers? true
     :show-files? (> (length files) 1)}))

(defun main (args)
  "main entry point for grainsearch CLI
   handles argument parsing, search execution, output"
  (let* ((config (parse-args args))
         (pattern-spec (:pattern config))
         (files (:files config))
         (results (if (= (first files) "stdin")
                      (search-lines (read-stdin-lines) pattern-spec config)
                      (search-files files pattern-spec config))))
    
    ;; output results (I/O boundary)
    (doseq [result results]
      (println (format-result result
                              (:show-line-numbers? config)
                              (:show-files? config))))
    
    ;; return exit code
    (if (empty? results) 1 0)))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ UTILITY FUNCTIONS (helpers and combinators)â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun compose (f g)
  "function composition: (f âˆ˜ g)(x) = f(g(x))"
  (lambda (x) (f (g x))))

(defun pipe (&rest fns)
  "pipeline composition: (pipe f g h)(x) = h(g(f(x)))"
  (reduce (lambda (acc fn)
            (lambda (x) (fn (acc x))))
          (lambda (x) x)
          fns))

(defun partial (f &rest args)
  "partial application of function"
  (lambda (&rest more-args)
    (apply f (concat args more-args))))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ EXAMPLE USAGE (documentation by example) â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

;; search for graintimes in files:
;; (search-files ["file1.md" "file2.md"] (graintime-pattern) (make-config nil " " false))

;; extract second field from results:
;; (map (compose (partial get-field 2) (partial extract-fields " ")) matching-lines)

;; count unique values in field 3:
;; (reduce (partial aggregate-line 3 " ") (make-aggregate) matching-lines)

;; find all grain box borders:
;; (search-lines input-lines (grain-box-pattern) (make-config nil " " false))

;; now == next + 1 âš–ï¸ ğŸŒ¾
