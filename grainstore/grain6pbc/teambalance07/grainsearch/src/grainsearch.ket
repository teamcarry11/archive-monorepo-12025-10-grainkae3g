;;; âœ§ï½¥ï¾Ÿ:* grainsearch.ket - search utility for grains (awk in ketos)
;;;
;;; team: 07 (teambalance07 - libra â™ / vii. the chariot)
;;; authored by: 14 (teamdescend14 - ketu â˜‹ / xiv. temperance)
;;;
;;; purpose: search, filter, and transform grain files using pattern matching
;;;          and text processing, entirely in ketos (no awk dependency).
;;;          
;;; the chariot's victory: movement with balance, action with equilibrium.
;;; libra's scales: weighing patterns, finding matches, balancing input/output.
;;;
;;; this tool searches grains like awk searches text, but with lisp elegance:
;;;   - pattern matching (regex, predicates, functions)
;;;   - field extraction (columns, components, metadata)
;;;   - transformations (map, filter, reduce over lines)
;;;   - aggregation (counts, sums, statistics)
;;;   - composability (chain operations functionally)
;;;
;;; âˆ¿âˆ¿âˆ¿ the chariot moves forward while maintaining perfect balance âˆ¿âˆ¿âˆ¿

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; core data structures (pattern, match, result)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

;; âœ¿ Pattern = Regex | Predicate | Function âœ¿
;;
;; a pattern can be:
;;   - regex string for text matching
;;   - predicate function (String â†’ Boolean)
;;   - transformation function (String â†’ a)

;; âœ¿ Match = {:line String, :line-number Integer, :fields [String]} âœ¿
;;
;; represents a matched line with its metadata

;; âœ¿ SearchResult = [Match] âœ¿
;;
;; collection of all matches from a search

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; line processing (the heart of text searching)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (split-fields line separator)
  ;; :: String â†’ String â†’ [String]
  ;;
  ;; split line into fields by separator (like awk's field splitting).
  ;;
  ;; examples:
  ;;   (split-fields "a:b:c" ":") â†’ ["a" "b" "c"]
  ;;   (split-fields "hello world" " ") â†’ ["hello" "world"]
  ;;
  ;; default separator is whitespace (like awk default)
  
  (if (equal? separator "")
      (string-split line #\space)  ; split on whitespace
      (string-split line separator)))

(define (match-pattern? line pattern)
  ;; :: String â†’ Pattern â†’ Boolean
  ;;
  ;; check if line matches pattern.
  ;;
  ;; pattern can be:
  ;;   - string (treated as regex)
  ;;   - function (applied as predicate)
  ;;
  ;; libra's scales: does this line balance with this pattern?
  
  (cond
    ((string? pattern)
     ;; regex match
     (string-contains? line pattern))  ; TODO: use actual regex when available
    
    ((function? pattern)
     ;; predicate match
     (pattern line))
    
    (else
     false)))

(define (process-line line line-number pattern action field-sep)
  ;; :: String â†’ Integer â†’ Pattern â†’ Action â†’ String â†’ Maybe Match
  ;;
  ;; process a single line: check pattern, apply action if matches.
  ;;
  ;; returns Match if pattern matches, nil otherwise.
  ;;
  ;; the chariot's movement: forward through text, balanced processing
  
  (when (match-pattern? line pattern)
    (let ((fields (split-fields line field-sep))
          (result (if action (action line fields) line)))
      {:line result
       :line-number line-number
       :fields fields
       :original line})))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; file processing (read and search)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (search-file filepath pattern action field-sep)
  ;; :: String â†’ Pattern â†’ Action â†’ String â†’ [Match]
  ;;
  ;; search entire file for pattern, applying action to matches.
  ;;
  ;; the chariot drives through the file, line by line, maintaining balance
  ;; between reading (input) and transforming (output).
  
  ;; TODO: implement file reading in ketos
  ;; (let ((lines (read-lines filepath)))
  ;;   (filter identity
  ;;     (map-indexed (lambda (idx line)
  ;;                   (process-line line (+ idx 1) pattern action field-sep))
  ;;                 lines)))
  
  ;; placeholder for now
  '())

(define (search-files filepaths pattern action field-sep)
  ;; :: [String] â†’ Pattern â†’ Action â†’ String â†’ [(String, [Match])]
  ;;
  ;; search multiple files, returning (filepath, matches) pairs.
  ;;
  ;; libra balances: process many files while keeping results organized
  
  (map (lambda (filepath)
        {:file filepath
         :matches (search-file filepath pattern action field-sep)})
       filepaths))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; common actions (what to do with matched lines)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (action-print line fields)
  ;; :: String â†’ [String] â†’ String
  ;;
  ;; default action: just print the line (like awk's default)
  line)

(define (action-print-field n)
  ;; :: Integer â†’ (String â†’ [String] â†’ String)
  ;;
  ;; return action that prints nth field (like awk's $1, $2, etc.)
  ;;
  ;; examples:
  ;;   ((action-print-field 1) "a:b:c" ["a" "b" "c"]) â†’ "a"
  ;;   ((action-print-field 2) "a:b:c" ["a" "b" "c"]) â†’ "b"
  
  (lambda (line fields)
    (if (< n (length fields))
        (nth fields n)
        "")))

(define (action-transform f)
  ;; :: (String â†’ String) â†’ Action
  ;;
  ;; return action that transforms line through function f
  ;;
  ;; examples:
  ;;   ((action-transform string-upcase) "hello" _) â†’ "HELLO"
  ;;   ((action-transform (lambda (s) (str ">>> " s))) "hi" _) â†’ ">>> hi"
  
  (lambda (line fields)
    (f line)))

(define (action-count)
  ;; :: () â†’ Action
  ;;
  ;; action that just counts matches (returns line number)
  ;;
  ;; use with aggregation to count total matches
  
  (lambda (line fields)
    "1"))  ; will be counted later

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; grain-specific patterns (domain knowledge)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (pattern-graintime)
  ;; :: () â†’ Pattern
  ;;
  ;; pattern matching valid graintime strings (76 chars)
  "12[0-9]{3}-[0-9]{2}-[0-9]{2}--[0-9]{4}-[A-Z]{3}--moon-")

(define (pattern-grain-code)
  ;; :: () â†’ Pattern
  ;;
  ;; pattern matching grain codes (xbdghj, etc.)
  "[xbdghjklmnsvz]{6}")

(define (pattern-ascii-box)
  ;; :: () â†’ Pattern  
  ;;
  ;; pattern matching ASCII box lines (â”‚ ... â”‚)
  "^â”‚.*â”‚$")

(define (predicate-empty-line)
  ;; :: String â†’ Boolean
  ;;
  ;; predicate: is line empty or only whitespace?
  (lambda (line)
    (equal? "" (string-trim line))))

(define (predicate-contains word)
  ;; :: String â†’ (String â†’ Boolean)
  ;;
  ;; predicate factory: line contains this word?
  (lambda (line)
    (string-contains? line word)))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; aggregation functions (reduce matches to insights)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (aggregate-count matches)
  ;; :: [Match] â†’ Integer
  ;;
  ;; count total matches (like awk's END {print NR})
  (length matches))

(define (aggregate-extract-field n matches)
  ;; :: Integer â†’ [Match] â†’ [String]
  ;;
  ;; extract nth field from all matches
  (map (lambda (m)
        (nth (get m :fields) n))
       matches))

(define (aggregate-unique-values matches key-fn)
  ;; :: [Match] â†’ (Match â†’ a) â†’ #{a}
  ;;
  ;; get unique values by applying key-fn to each match
  (set (map key-fn matches)))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; command-line interface (the chariot's reins)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (grainsearch pattern files options)
  ;; :: Pattern â†’ [String] â†’ Options â†’ IO ()
  ;;
  ;; main entry point for grainsearch.
  ;;
  ;; options:
  ;;   :field-sep â†’ field separator (default whitespace)
  ;;   :action â†’ what to do with matches (default print)
  ;;   :aggregate â†’ how to summarize results (default none)
  ;;   :case-insensitive â†’ ignore case (default false)
  ;;
  ;; examples:
  ;;   (grainsearch "graintime" ["*.md"] {})
  ;;   (grainsearch (predicate-contains "ketos") ["grains/*.md"] 
  ;;                {:action (action-print-field 0)})
  
  (let ((field-sep (or (get options :field-sep) ""))
        (action (or (get options :action) action-print))
        (aggregate-fn (get options :aggregate))
        (results (search-files files pattern action field-sep)))
    
    ;; print results
    (for-each (lambda (file-result)
               (let ((filepath (get file-result :file))
                     (matches (get file-result :matches)))
                 (when (not (empty? matches))
                   (println (format "{}:" filepath))
                   (for-each (lambda (match)
                              (println (format "  {}: {}" 
                                             (get match :line-number)
                                             (get match :line))))
                            matches))))
             results)
    
    ;; print aggregation if requested
    (when aggregate-fn
      (let ((all-matches (apply concat (map #(get % :matches) results))))
        (println "")
        (println (format "Total matches: {}" (aggregate-fn all-matches)))))))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; convenience functions (common use cases)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (find-graintimes files)
  ;; find all graintime strings in files
  (grainsearch (pattern-graintime) files {}))

(define (find-grain-codes files)
  ;; find all grain codes in files
  (grainsearch (pattern-grain-code) files {}))

(define (count-lines-matching pattern files)
  ;; count lines matching pattern (like grep -c)
  (grainsearch pattern files {:aggregate aggregate-count}))

(define (extract-field n pattern files)
  ;; extract nth field from lines matching pattern
  (grainsearch pattern files 
               {:action (action-print-field n)}))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; exports (public api)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(export grainsearch
        search-file
        search-files
        split-fields
        match-pattern?
        
        ;; actions
        action-print
        action-print-field
        action-transform
        action-count
        
        ;; patterns
        pattern-graintime
        pattern-grain-code
        pattern-ascii-box
        predicate-empty-line
        predicate-contains
        
        ;; aggregations
        aggregate-count
        aggregate-extract-field
        aggregate-unique-values
        
        ;; convenience
        find-graintimes
        find-grain-codes
        count-lines-matching
        extract-field)

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; usage examples
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(comment
  ;; example 1: find all graintime strings
  (find-graintimes ["grains/*.md"])
  ;; â†’ prints all lines containing graintimes
  
  ;; example 2: count grains mentioning "ketos"
  (count-lines-matching "ketos" ["grains/*.md"])
  ;; â†’ prints total count
  
  ;; example 3: extract grain codes from filenames
  (find-grain-codes ["grains/*"])
  ;; â†’ prints all 6-char codes found
  
  ;; example 4: find grains with box line count issues
  (grainsearch pattern-ascii-box
               ["grains/*.md"]
               {:aggregate (lambda (matches)
                            (let ((count (length matches)))
                              (if (equal? count 110)
                                  (format "âœ… perfect: {} box lines" count)
                                  (format "âŒ wrong: {} box lines (need 110)" count))))})
  
  ;; example 5: custom pattern and transformation
  (grainsearch (predicate-contains "helen")
               ["grains-helen-mode/*.md"]
               {:action (action-transform string-upcase)})
  ;; â†’ prints matching lines in UPPERCASE
  
  ;; example 6: field extraction (assuming colon-separated data)
  (extract-field 1 "graintime" ["logs/*.txt"])
  ;; â†’ extracts second field from lines containing "graintime"
  )

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; libra philosophy (balance in search)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

;; libra teaches balance through weighing. the scales don't judge - they measure.
;; grainsearch embodies this:
;;
;;   INPUT â†â†’ OUTPUT (balance what goes in with what comes out)
;;   PATTERN â†â†’ MATCH (balance strictness with flexibility)
;;   FILTER â†â†’ TRANSFORM (balance selection with modification)
;;   SPEED â†â†’ ACCURACY (balance performance with correctness)
;;
;; the chariot's victory: moving forward while staying centered.
;; grainsearch processes text without losing equilibrium.

;; the chariot (vii) governs:
;;   - movement with control
;;   - victory through balance
;;   - opposing forces harnessed
;;   - willpower aligned with wisdom
;;
;; applied to text search:
;;   - move through files (chariot's motion)
;;   - maintain pattern discipline (chariot's control)
;;   - balance input/output (opposing sphinxes harnessed)
;;   - achieve results through focused will (victory)

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; future enhancements
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

;; phase 1: basic implementation
;;   - file i/o (read lines from files)
;;   - regex matching (proper regex engine)
;;   - glob expansion (*.md â†’ actual file list)
;;   - streaming (don't load entire file into memory)
;;
;; phase 2: advanced features
;;   - multi-line patterns (like awk's RS)
;;   - begin/end blocks (like awk's BEGIN {} END {})
;;   - variables and state (like awk's built-in vars)
;;   - arithmetic operations (sum, avg, min, max)
;;
;; phase 3: grain-specific
;;   - parse grain headers automatically
;;   - validate 80Ã—110 format while searching
;;   - extract graintime components
;;   - aggregate grain statistics
;;
;; phase 4: optimization
;;   - parallel file processing
;;   - incremental results (stream output)
;;   - index building (cache for repeat searches)
;;   - rust integration (use ripgrep for speed)

;;; âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿
;;; end of grainsearch.ket
;;;
;;; the chariot moves with balance âš–ï¸
;;; the scales weigh with wisdom âˆ¿
;;;
;;; now == next + 1 âœ§ï½¥ï¾Ÿ:* ğŸŒ¾
;;;
;;; copyright Â© 2025 kae3g (kj3x39, @risc.love)
;;; team: 07 (teambalance07 - libra â™ / vii. the chariot)
;;; authored by: 14 (teamdescend14 - ketu â˜‹ / xiv. temperance)
;;; âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿

