;; âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿
;; grainsearch: functional text processing for grain ecosystem
;; âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿

;; team: 07 (teambalance07 - libra â™ / vii. the chariot)
;; authored by: 14 (teamdescend14 - ketu â˜‹ / xiv. temperance)
;; description: pattern matching and field extraction for grain files
;;              purely functional composition inspired by strong types
;;              balances simplicity with power (libra equilibrium)

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ TYPE SIGNATURES (expressed as comments, enforced through validation)    â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

;; line :: string
;; field :: string  
;; pattern :: (or regex-string predicate-fn transform-fn)
;; match-result :: {matched? bool, value any, captures [string]}
;; search-result :: {line string, line-num int, fields [field], matched? bool}
;; aggregation :: {count int, unique-values #{any}, stats {min max sum}}

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ CORE DATA STRUCTURES                                                    â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun make-match-result (matched? value captures)
  "construct match result record"
  {:matched? matched?
   :value value
   :captures captures})

(defun make-search-result (line line-num fields matched?)
  "construct search result record"
  {:line line
   :line-num line-num
   :fields fields
   :matched? matched?})

(defun make-aggregation (count unique-values stats)
  "construct aggregation record"
  {:count count
   :unique-values unique-values
   :stats stats})

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ PATTERN MATCHING FUNCTIONS                                              â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun match-regex (pattern-str line)
  "match regex pattern against line, return match-result"
  (let ((result (regex-match pattern-str line)))
    (if result
        (make-match-result true (first result) result)
        (make-match-result false nil '()))))

(defun match-predicate (pred-fn line)
  "apply predicate function to line, return match-result"
  (let ((result (pred-fn line)))
    (make-match-result result line '())))

(defun match-transform (transform-fn line)
  "apply transformation function to line, return match-result"
  (let ((result (transform-fn line)))
    (make-match-result (not (nil? result)) result '())))

(defun match-line (pattern line)
  "polymorphic pattern matching: handles regex, predicates, transforms"
  (cond
    ((string? pattern) (match-regex pattern line))
    ((function? pattern) (match-predicate pattern line))
    (else (make-match-result false nil '()))))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ FIELD EXTRACTION                                                        â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun split-fields (delimiter line)
  "split line into fields by delimiter (default: whitespace)"
  (if (nil? delimiter)
      (string-split line #"\s+")
      (string-split line delimiter)))

(defun extract-field (field-spec line)
  "extract field from line by index or name
   field-spec: int (column index) | regex (capture group)"
  (cond
    ((int? field-spec)
     (let ((fields (split-fields nil line)))
       (if (< field-spec (length fields))
           (nth fields field-spec)
           nil)))
    ((string? field-spec)
     (let ((match (match-regex field-spec line)))
       (if (:matched? match)
           (:value match)
           nil)))
    (else nil)))

(defun extract-fields (field-specs line)
  "extract multiple fields from line, return list of field values"
  (map (lambda (spec) (extract-field spec line)) field-specs))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ AGGREGATION FUNCTIONS                                                   â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun count-matches (results)
  "count total matching lines"
  (length (filter :matched? results)))

(defun unique-values (results field-index)
  "extract unique values from specific field across all results"
  (let ((field-values (map (lambda (r)
                             (nth (:fields r) field-index))
                           (filter :matched? results))))
    (into #{} field-values)))

(defun compute-stats (results field-index)
  "compute min/max/sum for numeric field"
  (let* ((field-values (map (lambda (r)
                              (string->number (nth (:fields r) field-index)))
                            (filter :matched? results)))
         (numbers (filter number? field-values)))
    (if (empty? numbers)
        {:min nil :max nil :sum nil :avg nil}
        {:min (apply min numbers)
         :max (apply max numbers)
         :sum (apply + numbers)
         :avg (/ (apply + numbers) (length numbers))})))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ GRAIN-SPECIFIC PATTERNS                                                 â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun grain-graintime? (line)
  "predicate: does line contain graintime timestamp?"
  (not (nil? (regex-match "\\d{5}-\\d{2}-\\d{2}--\\d{4}-[A-Z]{3}" line))))

(defun grain-code? (line)
  "predicate: does line contain 6-char grain code?"
  (not (nil? (regex-match "\\b[xbdghjklmnsvz]{6}\\b" line))))

(defun grain-box-border? (line)
  "predicate: is this an ASCII box border line?"
  (or (string-starts-with? line "â”Œ")
      (string-starts-with? line "â”œ")
      (string-starts-with? line "â””")
      (string-starts-with? line "â”‚")))

(defun extract-graintime (line)
  "extract graintime string from line"
  (let ((match (regex-match "\\d{5}-\\d{2}-\\d{2}--\\d{4}-[A-Z]{3}--moon-[a-z_]+--asc-[a-z]{4}\\d{2}-sun-\\d{2}h--team[a-z]+\\d{2}" line)))
    (if match (first match) nil)))

(defun extract-grain-code (line)
  "extract 6-char grain code from line"
  (let ((match (regex-match "\\b([xbdghjklmnsvz]{6})\\b" line)))
    (if match (second match) nil)))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ MAIN SEARCH PIPELINE                                                    â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun search-lines (pattern field-specs lines)
  "search lines with pattern, extract fields, return results
   this is the main composition point - pure data transformation"
  (map-indexed
   (lambda (idx line)
     (let* ((match (match-line pattern line))
            (matched? (:matched? match))
            (fields (if matched?
                        (extract-fields field-specs line)
                        '())))
       (make-search-result line (+ idx 1) fields matched?)))
   lines))

(defun search-file (pattern field-specs filepath)
  "search file with pattern, return results"
  (let ((lines (string-split-lines (slurp filepath))))
    (search-lines pattern field-specs lines)))

(defun filter-results (results)
  "filter to only matched results"
  (filter :matched? results))

(defun aggregate-results (results field-index agg-type)
  "aggregate results by type: 'count | 'unique | 'stats"
  (case agg-type
    ('count (make-aggregation (count-matches results) #{} {}))
    ('unique (make-aggregation 
              (count-matches results)
              (unique-values results field-index)
              {}))
    ('stats (make-aggregation
             (count-matches results)
             #{}
             (compute-stats results field-index)))
    (else (make-aggregation 0 #{} {}))))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ COMPOSITION HELPERS                                                     â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

(defun compose-patterns (patterns)
  "compose multiple patterns with AND logic"
  (lambda (line)
    (every? (lambda (p) (:matched? (match-line p line)))
            patterns)))

(defun or-patterns (patterns)
  "compose multiple patterns with OR logic"
  (lambda (line)
    (some? (lambda (p) (:matched? (match-line p line)))
           patterns)))

(defun pipe (initial-value & fns)
  "thread value through sequence of functions (pipeline operator)"
  (reduce (lambda (acc f) (f acc))
          initial-value
          fns))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ EXAMPLE USAGE PATTERNS                                                  â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

;; find all graintime strings in file:
;; (search-file grain-graintime? '(0) "path/to/file.md")

;; extract grain codes from all matching lines:
;; (->> (search-file grain-code? '() "path/to/file.md")
;;      (filter-results)
;;      (map (lambda (r) (extract-grain-code (:line r)))))

;; count lines containing both graintime AND grain code:
;; (let ((pattern (compose-patterns (list grain-graintime? grain-code?))))
;;   (count-matches (search-file pattern '() "path/to/file.md")))

;; aggregate unique nakshatra values from graintimes:
;; (let* ((results (search-file grain-graintime? '(0) "path/to/file.md"))
;;        (nakshatras (map (lambda (r)
;;                          (let ((gt (extract-graintime (:line r))))
;;                            (regex-match "moon-([a-z_]+)" gt)))
;;                        (filter-results results))))
;;   (into #{} (map second nakshatras)))

;; â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
;; â”‚ PHILOSOPHY: BALANCE THROUGH COMPOSITION                                 â”‚
;; â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

;; grainsearch embodies team 07 libra balance:
;;   - simple primitives (match, extract, aggregate)
;;   - powerful composition (pipe, compose, or)
;;   - clear data structures (records, not hidden state)
;;   - pure functions (no side effects except IO)
;;   - strong contracts (type signatures in comments)
;;
;; inspired by functional traditions without dogma. use what serves.
;; balanced movement forward - neither too simple nor too complex.
;; the chariot: opposing forces (simplicity/power) harnessed toward victory.

;; now == next + 1 âš–ï¸ ğŸŒ¾
