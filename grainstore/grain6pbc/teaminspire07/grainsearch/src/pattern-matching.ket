;;; âœ§ï½¥ï¾Ÿ:* pattern-matching.ket - pattern matching logic (decomplected)
;;;
;;; team: 07 (teambalance07 - libra â™ / vii. the chariot)
;;; authored by: 14 (teamdescend14 - ketu â˜‹ / xiv. temperance)
;;;
;;; purpose: all pattern matching logic in one place.
;;;          depends ONLY on data-structures.ket (simple dependency)
;;;
;;; this file does ONE thing: check if strings match patterns
;;; nothing else. no file i/o. no transformations. just matching.
;;;
;;; âˆ¿âˆ¿âˆ¿ libra weighs: does this text balance with this pattern? âˆ¿âˆ¿âˆ¿

(require 'data-structures)

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; core matching function (the scales of libra)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define (matches? line pattern case-sensitive)
  ;; :: String â†’ Pattern â†’ Boolean â†’ Boolean
  ;;
  ;; does line match pattern?
  ;;
  ;; SIMPLE: one question, one answer
  ;; NOT COMPLECTED: doesn't mix matching with transforming or counting
  ;;
  ;; this is the CORE function - everything else builds on this
  
  (let ((line-to-check (if case-sensitive 
                          line 
                          (string-downcase line))))
    
    (case (pattern-type pattern)
      (:regex
       ;; regex matching
       (let ((pattern-str (get pattern :pattern))
             (pattern-to-check (if case-sensitive
                                  pattern-str
                                  (string-downcase pattern-str))))
         ;; TODO: use actual regex engine when available in ketos
         ;; for now: simple substring matching
         (string-contains? line-to-check pattern-to-check)))
      
      (:predicate
       ;; predicate matching
       (let ((pred-fn (get pattern :fn)))
         (pred-fn line-to-check)))
      
      (:function
       ;; function patterns always "match" - they transform
       true)
      
      (else
       false))))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; grain-specific patterns (domain knowledge separated)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(define pattern-graintime
  "pattern matching 76-char graintime strings"
  (regex-pattern "12[0-9]{3}-[0-9]{2}-[0-9]{2}--[0-9]{4}-[A-Z]{3}--moon-"))

(define pattern-grain-code
  "pattern matching 6-char grain codes (xbdghj etc)"
  (regex-pattern "[xbdghjklmnsvz]{6}"))

(define pattern-ascii-box-line
  "pattern matching ASCII box lines (â”‚ ... â”‚)"
  (regex-pattern "^â”‚.*â”‚$"))

(define pattern-empty-line
  "pattern matching empty or whitespace-only lines"
  (predicate-pattern (lambda (line)
                      (equal? "" (string-trim line)))))

(define (pattern-contains-word word)
  "factory: pattern matching lines containing specific word"
  (regex-pattern word))

(define (pattern-line-length min max)
  "factory: pattern matching lines within length range"
  (predicate-pattern (lambda (line)
                      (let ((len (string-length line)))
                        (and (>= len min) (<= len max))))))

(define pattern-80-chars-wide
  "pattern matching lines exactly 80 display characters wide"
  (predicate-pattern (lambda (line)
                      ;; TODO: use display-width function (unicode-aware)
                      (equal? 80 (string-length line)))))

;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
;;; tests (extensive edge case coverage)
;;; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(comment
  ;; test: basic regex matching (case sensitive)
  (assert (matches? "hello world" (regex-pattern "world") true))
  (assert (not (matches? "hello world" (regex-pattern "WORLD") true)))
  
  ;; test: basic regex matching (case insensitive)
  (assert (matches? "hello WORLD" (regex-pattern "world") false))
  (assert (matches? "HELLO world" (regex-pattern "HELLO") false))
  
  ;; test: predicate matching
  (let ((long-lines (predicate-pattern (lambda (s) (> (string-length s) 50)))))
    (assert (matches? (make-string 60 #\x) long-lines true))
    (assert (not (matches? "short" long-lines true))))
  
  ;; test: function patterns always match
  (let ((upcase-pattern (function-pattern string-upcase)))
    (assert (matches? "anything" upcase-pattern true))
    (assert (matches? "" upcase-pattern true)))
  
  ;; test: graintime pattern
  (assert (matches? "12025-10-27--0145-PDT--moon-p_ashadha----asc-leo023-sun-03h"
                   pattern-graintime
                   true))
  (assert (not (matches? "2025-10-27" pattern-graintime true)))
  
  ;; test: grain code pattern
  (assert (matches? "grain: xbdghj (1 of 1.2M)" pattern-grain-code true))
  (assert (not (matches? "grain: abc123" pattern-grain-code true)))
  
  ;; test: ASCII box line pattern
  (assert (matches? "â”‚ hello world                                                                 â”‚"
                   pattern-ascii-box-line
                   true))
  (assert (not (matches? "hello world" pattern-ascii-box-line true)))
  
  ;; test: empty line pattern
  (assert (matches? "" pattern-empty-line true))
  (assert (matches? "   " pattern-empty-line true))
  (assert (not (matches? "a" pattern-empty-line true)))
  
  ;; test: line length pattern
  (let ((short-lines (pattern-line-length 0 10)))
    (assert (matches? "hi" short-lines true))
    (assert (matches? "1234567890" short-lines true))
    (assert (not (matches? "this is way too long for the pattern" short-lines true))))
  
  ;; edge case: empty string matching
  (assert (matches? "" (regex-pattern "") true))
  
  ;; edge case: pattern matching itself
  (assert (matches? "pattern" (regex-pattern "pattern") true))
  
  ;; edge case: unicode in pattern (TODO: handle properly)
  ;; (assert (matches? "hello ğŸŒ¾ world" (regex-pattern "ğŸŒ¾") true))
  )

;;; âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿
;;; simple made easy: pattern matching edition
;;; âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿
;;;
;;; SIMPLE:
;;;   - matches? does ONE thing: check if string matches pattern
;;;   - patterns are JUST data (regex string, predicate fn, transform fn)
;;;   - case-sensitivity is EXPLICIT parameter (not hidden state)
;;;
;;; NOT COMPLECTED:
;;;   - doesn't read files (that's file-io.ket's job)
;;;   - doesn't transform results (that's transformations.ket's job)
;;;   - doesn't aggregate counts (that's aggregations.ket's job)
;;;
;;; TESTABLE:
;;;   - no i/o = no mocks needed
;;;   - pure functions = same input â†’ same output always
;;;   - edge cases clearly defined in tests
;;;
;;; âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿
;;; end of pattern-matching.ket
;;;
;;; libra's scales weigh truth âš–ï¸
;;; now == next + 1 âœ§ï½¥ï¾Ÿ:* ğŸŒ¾
;;; âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿âˆ¿

